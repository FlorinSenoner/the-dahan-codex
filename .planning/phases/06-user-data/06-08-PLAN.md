---
phase: 06-user-data
plan: 08
type: execute
wave: 4
depends_on: ["06-05", "06-06"]
files_modified:
  - app/lib/csv-import.ts
  - app/routes/_authenticated/games.import.tsx
  - app/components/games/csv-preview.tsx
  - convex/games.ts
autonomous: true

must_haves:
  truths:
    - "User can upload a CSV file for import"
    - "Import shows preview before confirming"
    - "Matching IDs result in full replacement of existing games"
    - "New IDs create new games"
    - "Invalid rows are shown with errors"
  artifacts:
    - path: "app/lib/csv-import.ts"
      provides: "CSV parsing and validation"
      exports: ["parseGamesCSV", "validateParsedGame"]
    - path: "app/routes/_authenticated/games.import.tsx"
      provides: "Import page with upload and preview"
      contains: "importGames"
    - path: "app/components/games/csv-preview.tsx"
      provides: "Preview table for import"
      exports: ["CSVPreview"]
    - path: "convex/games.ts"
      provides: "importGames mutation for bulk upsert"
      exports: ["importGames"]
  key_links:
    - from: "app/lib/csv-import.ts"
      to: "papaparse"
      via: "Papa.parse for CSV parsing"
      pattern: "Papa.parse"
    - from: "app/routes/_authenticated/games.import.tsx"
      to: "convex/games.ts"
      via: "useMutation for importGames"
      pattern: "api.games.importGames"
---

<objective>
Implement CSV import with preview and ID-based sync.

Purpose: Users can import games from CSV, preview changes before confirming, and sync with existing data using ID-based matching.
Output: CSV import utility, preview component, import page, and importGames mutation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-user-data/06-CONTEXT.md
@.planning/phases/06-user-data/06-RESEARCH.md
@app/lib/csv-export.ts
@convex/games.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CSV import utility</name>
  <files>app/lib/csv-import.ts</files>
  <action>
Create `app/lib/csv-import.ts`:

```typescript
import Papa from "papaparse";

/**
 * Parsed row from CSV (matches export column structure)
 */
export interface ParsedGameRow {
  id: string;
  date: string;
  result: string;
  spirit1: string;
  spirit1_variant: string;
  spirit1_player: string;
  spirit2: string;
  spirit2_variant: string;
  spirit2_player: string;
  spirit3: string;
  spirit3_variant: string;
  spirit3_player: string;
  spirit4: string;
  spirit4_variant: string;
  spirit4_player: string;
  spirit5: string;
  spirit5_variant: string;
  spirit5_player: string;
  spirit6: string;
  spirit6_variant: string;
  spirit6_player: string;
  adversary: string;
  adversary_level: string;
  secondary_adversary: string;
  secondary_adversary_level: string;
  scenario: string;
  scenario_difficulty: string;
  win_type: string;
  invader_stage: string;
  blight_count: string;
  dahan_count: string;
  cards_remaining: string;
  score: string;
  notes: string;
}

/**
 * Validated game ready for import
 */
export interface ValidatedGame {
  row: ParsedGameRow;
  isValid: boolean;
  errors: string[];
  isNew: boolean; // true if ID doesn't match existing game
}

/**
 * Parse CSV file to rows
 */
export function parseGamesCSV(file: File): Promise<ParsedGameRow[]> {
  return new Promise((resolve, reject) => {
    Papa.parse<ParsedGameRow>(file, {
      header: true,
      skipEmptyLines: true,
      dynamicTyping: false, // Keep as strings for validation
      complete: (results) => {
        if (results.errors.length > 0) {
          reject(new Error(`Parse errors: ${results.errors.map(e => e.message).join(", ")}`));
          return;
        }
        resolve(results.data);
      },
      error: reject,
    });
  });
}

/**
 * Validate a parsed game row
 */
export function validateParsedGame(row: ParsedGameRow, existingIds: Set<string>): ValidatedGame {
  const errors: string[] = [];

  // Required: date
  if (!row.date) {
    errors.push("Missing date");
  } else if (!/^\d{4}-\d{2}-\d{2}$/.test(row.date)) {
    errors.push("Invalid date format (expected YYYY-MM-DD)");
  }

  // Required: result
  if (!row.result) {
    errors.push("Missing result");
  } else if (row.result !== "win" && row.result !== "loss") {
    errors.push("Result must be 'win' or 'loss'");
  }

  // Required: at least one spirit
  const hasSpirit = row.spirit1 || row.spirit2 || row.spirit3 || row.spirit4 || row.spirit5 || row.spirit6;
  if (!hasSpirit) {
    errors.push("At least one spirit is required");
  }

  // Validate adversary level if adversary provided
  if (row.adversary && row.adversary_level) {
    const level = parseInt(row.adversary_level, 10);
    if (isNaN(level) || level < 0 || level > 6) {
      errors.push("Adversary level must be 0-6");
    }
  }

  // Check if this is an update or new game
  const isNew = !row.id || !existingIds.has(row.id);

  return {
    row,
    isValid: errors.length === 0,
    errors,
    isNew,
  };
}

/**
 * Convert validated row to game data for import
 */
export function rowToGameData(row: ParsedGameRow) {
  const spirits = [];

  // Collect spirits 1-6
  const spiritFields = [
    { name: row.spirit1, variant: row.spirit1_variant, player: row.spirit1_player },
    { name: row.spirit2, variant: row.spirit2_variant, player: row.spirit2_player },
    { name: row.spirit3, variant: row.spirit3_variant, player: row.spirit3_player },
    { name: row.spirit4, variant: row.spirit4_variant, player: row.spirit4_player },
    { name: row.spirit5, variant: row.spirit5_variant, player: row.spirit5_player },
    { name: row.spirit6, variant: row.spirit6_variant, player: row.spirit6_player },
  ];

  for (const spirit of spiritFields) {
    if (spirit.name) {
      spirits.push({
        name: spirit.name,
        variant: spirit.variant || undefined,
        player: spirit.player || undefined,
      });
    }
  }

  return {
    existingId: row.id || undefined,
    date: row.date,
    result: row.result as "win" | "loss",
    spirits,
    adversary: row.adversary ? {
      name: row.adversary,
      level: parseInt(row.adversary_level, 10) || 0,
    } : undefined,
    secondaryAdversary: row.secondary_adversary ? {
      name: row.secondary_adversary,
      level: parseInt(row.secondary_adversary_level, 10) || 0,
    } : undefined,
    scenario: row.scenario ? {
      name: row.scenario,
      difficulty: row.scenario_difficulty ? parseInt(row.scenario_difficulty, 10) : undefined,
    } : undefined,
    winType: row.win_type || undefined,
    invaderStage: row.invader_stage ? parseInt(row.invader_stage, 10) : undefined,
    blightCount: row.blight_count ? parseInt(row.blight_count, 10) : undefined,
    dahanCount: row.dahan_count ? parseInt(row.dahan_count, 10) : undefined,
    cardsRemaining: row.cards_remaining ? parseInt(row.cards_remaining, 10) : undefined,
    score: row.score ? parseInt(row.score, 10) : undefined,
    notes: row.notes || undefined,
  };
}
```
  </action>
  <verify>Run `pnpm typecheck` - file should compile without errors.</verify>
  <done>CSV import utility exists with parseGamesCSV, validateParsedGame, and rowToGameData functions.</done>
</task>

<task type="auto">
  <name>Task 2: Add importGames mutation to Convex</name>
  <files>convex/games.ts</files>
  <action>
Add an `importGames` mutation to `convex/games.ts`:

```typescript
// Mutation to import games from CSV (upsert by ID)
export const importGames = mutation({
  args: {
    games: v.array(v.object({
      existingId: v.optional(v.string()), // Original game ID if updating
      date: v.string(),
      result: v.union(v.literal("win"), v.literal("loss")),
      spirits: v.array(v.object({
        name: v.string(),
        variant: v.optional(v.string()),
        player: v.optional(v.string()),
      })),
      adversary: v.optional(v.object({
        name: v.string(),
        level: v.number(),
      })),
      secondaryAdversary: v.optional(v.object({
        name: v.string(),
        level: v.number(),
      })),
      scenario: v.optional(v.object({
        name: v.string(),
        difficulty: v.optional(v.number()),
      })),
      winType: v.optional(v.string()),
      invaderStage: v.optional(v.number()),
      blightCount: v.optional(v.number()),
      dahanCount: v.optional(v.number()),
      cardsRemaining: v.optional(v.number()),
      score: v.optional(v.number()),
      notes: v.optional(v.string()),
    })),
  },
  handler: async (ctx, args) => {
    const identity = await requireAuth(ctx);
    const now = Date.now();

    let created = 0;
    let updated = 0;

    for (const gameData of args.games) {
      const { existingId, spirits, ...data } = gameData;

      // Note: Import doesn't link to spirit IDs since CSV uses names
      // Create spirit entries with null spiritId (will show name but not link)
      const spiritsWithNullIds = spirits.map(s => ({
        spiritId: null as unknown as Id<"spirits">, // Import doesn't resolve IDs
        name: s.name,
        variant: s.variant,
        player: s.player,
      }));

      if (existingId) {
        // Try to find and update existing game
        const existingGame = await ctx.db.get(existingId as Id<"games">);
        if (existingGame && existingGame.userId === identity.tokenIdentifier) {
          // Full replacement per CONTEXT.md
          await ctx.db.replace(existingId as Id<"games">, {
            ...data,
            spirits: spiritsWithNullIds,
            userId: identity.tokenIdentifier,
            createdAt: existingGame.createdAt,
            updatedAt: now,
          });
          updated++;
          continue;
        }
      }

      // Create new game
      await ctx.db.insert("games", {
        ...data,
        spirits: spiritsWithNullIds,
        userId: identity.tokenIdentifier,
        createdAt: now,
        updatedAt: now,
      });
      created++;
    }

    return { created, updated };
  },
});
```

Note: This mutation uses `replace` for updates to match the "full replacement" requirement from CONTEXT.md - missing fields in the import will be removed from the existing record.
  </action>
  <verify>Run `npx convex dev` to verify the mutation compiles.</verify>
  <done>importGames mutation handles bulk upsert with ID-based matching and full replacement.</done>
</task>

<task type="auto">
  <name>Task 3: Create CSVPreview component and import page</name>
  <files>app/components/games/csv-preview.tsx, app/routes/_authenticated/games.import.tsx</files>
  <action>
1. Create `app/components/games/csv-preview.tsx`:

```typescript
import type { ValidatedGame } from "@/lib/csv-import";
import { Badge } from "@/components/ui/badge";
import { AlertCircle, CheckCircle, Plus, RefreshCw } from "lucide-react";

interface CSVPreviewProps {
  games: ValidatedGame[];
}

export function CSVPreview({ games }: CSVPreviewProps) {
  const validCount = games.filter(g => g.isValid).length;
  const invalidCount = games.length - validCount;
  const newCount = games.filter(g => g.isValid && g.isNew).length;
  const updateCount = games.filter(g => g.isValid && !g.isNew).length;

  return (
    <div className="space-y-4">
      {/* Summary */}
      <div className="flex gap-4 text-sm">
        <span className="text-muted-foreground">
          {games.length} games in file
        </span>
        {validCount > 0 && (
          <span className="text-green-600 flex items-center gap-1">
            <CheckCircle className="h-4 w-4" />
            {validCount} valid
          </span>
        )}
        {invalidCount > 0 && (
          <span className="text-destructive flex items-center gap-1">
            <AlertCircle className="h-4 w-4" />
            {invalidCount} invalid
          </span>
        )}
      </div>

      {/* Action breakdown */}
      <div className="flex gap-4 text-sm">
        {newCount > 0 && (
          <Badge variant="secondary" className="gap-1">
            <Plus className="h-3 w-3" />
            {newCount} new
          </Badge>
        )}
        {updateCount > 0 && (
          <Badge variant="secondary" className="gap-1">
            <RefreshCw className="h-3 w-3" />
            {updateCount} updates
          </Badge>
        )}
      </div>

      {/* Game list */}
      <div className="border rounded-lg divide-y max-h-96 overflow-auto">
        {games.map((game, i) => (
          <div
            key={i}
            className={`p-3 ${!game.isValid ? "bg-destructive/10" : ""}`}
          >
            <div className="flex items-center justify-between">
              <div className="flex-1 min-w-0">
                <div className="font-medium truncate">
                  {game.row.date} — {game.row.spirit1}
                  {game.row.spirit2 && ` +${[game.row.spirit2, game.row.spirit3, game.row.spirit4, game.row.spirit5, game.row.spirit6].filter(Boolean).length} more`}
                </div>
                <div className="text-sm text-muted-foreground">
                  {game.row.adversary ? `vs ${game.row.adversary} L${game.row.adversary_level}` : "No adversary"}
                  {" • "}
                  {game.row.result === "win" ? "Win" : "Loss"}
                </div>
              </div>
              <div className="flex items-center gap-2">
                {game.isNew ? (
                  <Badge variant="outline" className="text-xs">New</Badge>
                ) : (
                  <Badge variant="outline" className="text-xs">Update</Badge>
                )}
                {!game.isValid && (
                  <Badge variant="destructive" className="text-xs">Invalid</Badge>
                )}
              </div>
            </div>
            {game.errors.length > 0 && (
              <div className="mt-2 text-sm text-destructive">
                {game.errors.join(", ")}
              </div>
            )}
          </div>
        ))}
      </div>
    </div>
  );
}
```

2. Create `app/routes/_authenticated/games.import.tsx`:

```typescript
import * as React from "react";
import { createFileRoute, useNavigate, Link } from "@tanstack/react-router";
import { useSuspenseQuery, useMutation } from "@tanstack/react-query";
import { convexQuery, useConvexMutation } from "@convex-dev/react-query";
import { api } from "convex/_generated/api";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import { CSVPreview } from "@/components/games/csv-preview";
import {
  parseGamesCSV,
  validateParsedGame,
  rowToGameData,
  type ValidatedGame,
} from "@/lib/csv-import";
import { Upload, ArrowLeft, Loader2 } from "lucide-react";

export const Route = createFileRoute("/_authenticated/games/import")({
  component: ImportPage,
});

function ImportPage() {
  const navigate = useNavigate();
  const [validatedGames, setValidatedGames] = React.useState<ValidatedGame[] | null>(null);
  const fileInputRef = React.useRef<HTMLInputElement>(null);

  // Get existing game IDs for validation
  const { data: existingGames } = useSuspenseQuery(
    convexQuery(api.games.listGames, {})
  );
  const existingIds = new Set(existingGames.map(g => g._id));

  const importGames = useMutation({
    mutationFn: useConvexMutation(api.games.importGames),
    onSuccess: (result) => {
      toast.success(`Imported ${result.created} new, updated ${result.updated} existing`);
      navigate({ to: "/games" });
    },
    onError: (error) => {
      toast.error(`Import failed: ${error.message}`);
    },
  });

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    try {
      const rows = await parseGamesCSV(file);
      const validated = rows.map(row => validateParsedGame(row, existingIds));
      setValidatedGames(validated);
    } catch (error) {
      toast.error(`Failed to parse CSV: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  };

  const handleImport = async () => {
    if (!validatedGames) return;

    const validGames = validatedGames
      .filter(g => g.isValid)
      .map(g => rowToGameData(g.row));

    if (validGames.length === 0) {
      toast.error("No valid games to import");
      return;
    }

    await importGames.mutateAsync({ games: validGames });
  };

  const validCount = validatedGames?.filter(g => g.isValid).length ?? 0;

  return (
    <div className="p-4 space-y-6">
      {/* Back link */}
      <Link to="/games" className="flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground">
        <ArrowLeft className="h-4 w-4" />
        Back to Games
      </Link>

      <h2 className="text-xl font-semibold">Import Games from CSV</h2>

      <p className="text-muted-foreground">
        Upload a CSV file exported from The Dahan Codex or a compatible format.
        Games with matching IDs will be replaced; new IDs will create new games.
      </p>

      {/* File upload */}
      <div className="space-y-4">
        <input
          ref={fileInputRef}
          type="file"
          accept=".csv"
          onChange={handleFileChange}
          className="hidden"
        />
        <Button
          variant="outline"
          onClick={() => fileInputRef.current?.click()}
        >
          <Upload className="h-4 w-4 mr-2" />
          Select CSV File
        </Button>
      </div>

      {/* Preview */}
      {validatedGames && (
        <div className="space-y-4">
          <h3 className="font-semibold">Preview</h3>
          <CSVPreview games={validatedGames} />

          <div className="flex gap-2">
            <Button
              onClick={handleImport}
              disabled={validCount === 0 || importGames.isPending}
            >
              {importGames.isPending ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  Importing...
                </>
              ) : (
                `Import ${validCount} Game${validCount === 1 ? "" : "s"}`
              )}
            </Button>
            <Button variant="outline" onClick={() => setValidatedGames(null)}>
              Cancel
            </Button>
          </div>
        </div>
      )}
    </div>
  );
}
```

3. Add Import link to games index action bar (alongside Export):
```typescript
<Link to="/games/import">
  <Button variant="outline" size="sm">
    <Upload className="h-4 w-4 mr-2" />
    Import CSV
  </Button>
</Link>
```
  </action>
  <verify>Run `pnpm dev`. Go to /games, click Import CSV. Upload a CSV file. Verify preview shows. Click Import. Verify games are imported.</verify>
  <done>Import page exists at /games/import with file upload, preview, and import confirmation.</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. /games/import route accessible
3. CSV upload parses and validates
4. Preview shows valid/invalid games with errors
5. Preview shows new vs update badges
6. Import button creates/updates games
7. Success toast shows counts and redirects to list
</verification>

<success_criteria>
- CSV import parses using PapaParse
- Validation checks required fields and formats
- Preview shows all games with status (valid/invalid, new/update)
- Import uses ID-based sync (full replacement)
- Invalid rows are skipped but shown in preview
- Build and typecheck pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-user-data/06-08-SUMMARY.md`
</output>

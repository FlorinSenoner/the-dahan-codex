---
phase: 06-user-data
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/games.ts
  - convex/lib/scoring.ts
autonomous: true

must_haves:
  truths:
    - "Authenticated user can create a game via mutation"
    - "Authenticated user can list only their own games"
    - "Authenticated user can update their own game"
    - "Authenticated user can soft-delete their own game"
    - "Authenticated user can restore a soft-deleted game"
    - "Score can be calculated using Spirit Island formula"
  artifacts:
    - path: "convex/games.ts"
      provides: "Game CRUD mutations and queries"
      exports: ["listGames", "getGame", "createGame", "updateGame", "deleteGame", "restoreGame"]
    - path: "convex/lib/scoring.ts"
      provides: "Spirit Island score calculation"
      exports: ["calculateScore"]
  key_links:
    - from: "convex/games.ts"
      to: "convex/lib/auth.ts"
      via: "requireAuth import"
      pattern: "requireAuth"
    - from: "convex/games.ts"
      to: "convex/lib/scoring.ts"
      via: "calculateScore import"
      pattern: "calculateScore"
---

<objective>
Create Convex mutations and queries for game CRUD operations.

Purpose: Backend functions that enable creating, reading, updating, and deleting games with proper user scoping and soft delete support.
Output: convex/games.ts with all CRUD operations, convex/lib/scoring.ts with score calculation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-user-data/06-CONTEXT.md
@.planning/phases/06-user-data/06-RESEARCH.md
@convex/schema.ts
@convex/lib/auth.ts
@convex/openings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create score calculation utility</name>
  <files>convex/lib/scoring.ts</files>
  <action>
Create `convex/lib/scoring.ts` with the Spirit Island score calculation formula:

```typescript
/**
 * Spirit Island official score calculation
 * Source: Official Spirit Island rules (Dized)
 */
interface ScoreParams {
  result: "win" | "loss";
  difficulty: number;
  cardsRemaining: number; // Cards left in invader deck
  dahanCount: number;
  blightCount: number;
  playerCount: number;
}

/**
 * Calculate Spirit Island game score
 *
 * Victory: (5 x Difficulty) + 10 + (2 x cards remaining) + (dahan / players) - (blight / players)
 * Defeat: (2 x Difficulty) + cards used + (dahan / players) - (blight / players)
 *
 * Note: cards used for defeat = total invader deck cards - cards remaining
 * Standard invader deck has 12 cards (3 per stage)
 */
export function calculateScore(params: ScoreParams): number {
  const { result, difficulty, cardsRemaining, dahanCount, blightCount, playerCount } = params;

  // Dahan and blight are divided by player count and floored
  const dahanScore = Math.floor(dahanCount / playerCount);
  const blightPenalty = Math.floor(blightCount / playerCount);

  if (result === "win") {
    // Victory formula
    return (5 * difficulty) + 10 + (2 * cardsRemaining) + dahanScore - blightPenalty;
  } else {
    // Defeat formula - cards used is 12 (standard deck) minus remaining
    const cardsUsed = 12 - cardsRemaining;
    return (2 * difficulty) + cardsUsed + dahanScore - blightPenalty;
  }
}

/**
 * Calculate difficulty from adversary and scenario
 * This is a simplified version - full difficulty calculation would need adversary/scenario reference data
 */
export function calculateDifficulty(
  adversaryLevel: number = 0,
  secondaryAdversaryLevel: number = 0,
  scenarioDifficulty: number = 0
): number {
  return adversaryLevel + secondaryAdversaryLevel + scenarioDifficulty;
}
```
  </action>
  <verify>Run `pnpm typecheck` - file should compile without errors.</verify>
  <done>Score calculation utility exists with calculateScore and calculateDifficulty functions.</done>
</task>

<task type="auto">
  <name>Task 2: Create game CRUD mutations and queries</name>
  <files>convex/games.ts</files>
  <action>
Create `convex/games.ts` with all CRUD operations:

```typescript
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { requireAuth } from "./lib/auth";

// Query to list all non-deleted games for the authenticated user
export const listGames = query({
  args: {},
  handler: async (ctx) => {
    const identity = await requireAuth(ctx);
    return await ctx.db
      .query("games")
      .withIndex("by_user", (q) => q.eq("userId", identity.tokenIdentifier))
      .filter((q) => q.eq(q.field("deletedAt"), undefined))
      .order("desc")
      .collect();
  },
});

// Query to get a single game by ID (with ownership check)
export const getGame = query({
  args: { id: v.id("games") },
  handler: async (ctx, args) => {
    const identity = await requireAuth(ctx);
    const game = await ctx.db.get(args.id);
    if (!game || game.userId !== identity.tokenIdentifier) {
      return null;
    }
    return game;
  },
});

// Mutation to create a new game
export const createGame = mutation({
  args: {
    date: v.string(),
    result: v.union(v.literal("win"), v.literal("loss")),
    spirits: v.array(v.object({
      spiritId: v.id("spirits"),
      name: v.string(),
      variant: v.optional(v.string()),
      player: v.optional(v.string()),
    })),
    adversary: v.optional(v.object({
      name: v.string(),
      level: v.number(),
    })),
    secondaryAdversary: v.optional(v.object({
      name: v.string(),
      level: v.number(),
    })),
    scenario: v.optional(v.object({
      name: v.string(),
      difficulty: v.optional(v.number()),
    })),
    winType: v.optional(v.string()),
    invaderStage: v.optional(v.number()),
    blightCount: v.optional(v.number()),
    dahanCount: v.optional(v.number()),
    cardsRemaining: v.optional(v.number()),
    score: v.optional(v.number()),
    notes: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await requireAuth(ctx);
    const now = Date.now();

    // Validate at least one spirit
    if (args.spirits.length === 0) {
      throw new Error("At least one spirit is required");
    }
    if (args.spirits.length > 6) {
      throw new Error("Maximum 6 spirits allowed");
    }

    return await ctx.db.insert("games", {
      ...args,
      userId: identity.tokenIdentifier,
      createdAt: now,
      updatedAt: now,
    });
  },
});

// Mutation to update an existing game
export const updateGame = mutation({
  args: {
    id: v.id("games"),
    date: v.optional(v.string()),
    result: v.optional(v.union(v.literal("win"), v.literal("loss"))),
    spirits: v.optional(v.array(v.object({
      spiritId: v.id("spirits"),
      name: v.string(),
      variant: v.optional(v.string()),
      player: v.optional(v.string()),
    }))),
    adversary: v.optional(v.object({
      name: v.string(),
      level: v.number(),
    })),
    secondaryAdversary: v.optional(v.object({
      name: v.string(),
      level: v.number(),
    })),
    scenario: v.optional(v.object({
      name: v.string(),
      difficulty: v.optional(v.number()),
    })),
    winType: v.optional(v.string()),
    invaderStage: v.optional(v.number()),
    blightCount: v.optional(v.number()),
    dahanCount: v.optional(v.number()),
    cardsRemaining: v.optional(v.number()),
    score: v.optional(v.number()),
    notes: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await requireAuth(ctx);
    const game = await ctx.db.get(args.id);

    if (!game || game.userId !== identity.tokenIdentifier) {
      throw new Error("Game not found");
    }

    const { id, ...updates } = args;

    // Validate spirits if provided
    if (updates.spirits !== undefined) {
      if (updates.spirits.length === 0) {
        throw new Error("At least one spirit is required");
      }
      if (updates.spirits.length > 6) {
        throw new Error("Maximum 6 spirits allowed");
      }
    }

    await ctx.db.patch(id, {
      ...updates,
      updatedAt: Date.now(),
    });
  },
});

// Mutation to soft-delete a game
export const deleteGame = mutation({
  args: { id: v.id("games") },
  handler: async (ctx, args) => {
    const identity = await requireAuth(ctx);
    const game = await ctx.db.get(args.id);

    if (!game || game.userId !== identity.tokenIdentifier) {
      throw new Error("Game not found");
    }

    await ctx.db.patch(args.id, {
      deletedAt: Date.now(),
    });
  },
});

// Mutation to restore a soft-deleted game (for undo)
export const restoreGame = mutation({
  args: { id: v.id("games") },
  handler: async (ctx, args) => {
    const identity = await requireAuth(ctx);
    const game = await ctx.db.get(args.id);

    if (!game || game.userId !== identity.tokenIdentifier) {
      throw new Error("Game not found");
    }

    await ctx.db.patch(args.id, {
      deletedAt: undefined,
    });
  },
});
```

Follow the patterns from `convex/openings.ts` for mutation structure and error handling.
  </action>
  <verify>Run `pnpm typecheck` - all functions should compile. Run `npx convex dev` to verify functions are registered.</verify>
  <done>convex/games.ts exists with listGames, getGame, createGame, updateGame, deleteGame, restoreGame. All operations verify user ownership via identity.tokenIdentifier.</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. `npx convex dev` shows games functions registered
3. All mutations check user ownership before modifying data
4. listGames filters out soft-deleted games
5. deleteGame sets deletedAt, restoreGame clears it
</verification>

<success_criteria>
- convex/games.ts exports all 6 functions
- convex/lib/scoring.ts exports calculateScore and calculateDifficulty
- All mutations require authentication and verify ownership
- Soft delete pattern implemented with deletedAt field
- Build and typecheck pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-user-data/06-02-SUMMARY.md`
</output>

# Phase 3.4: Presence Track Graph DSL - Research

**Researched:** 2026-01-27
**Domain:** Data modeling, graph representation, CSS Grid rendering
**Confidence:** HIGH

## Summary

This phase redesigns the presence track DSL to support graph-based structures for complex spirits (Finder of Paths Unseen, Starlight Seeks Its Form, Serpent Slumbering). The critical context is that **backward compatibility is NOT required** - all spirits will be re-seeded to the new unified format.

After re-evaluating all three options without backward compatibility constraints:

1. **Option A: Node-Edge Graph Model** - Explicit nodes + edges
2. **Option B: Adjacency List Model** - Nodes with adjacent array
3. **Option C: Grid + Connections Hybrid** - 2D grid + non-adjacent connections

**Primary recommendation:** **Option A (Node-Edge Graph Model)** is the cleanest, most maintainable solution when backward compatibility is removed. It provides maximum expressiveness, eliminates null cells, and is the most accurate representation of graph topology.

## Problem Recap

The current DSL uses linear tracks with `connectsTo` which cannot represent:
- **Bidirectional traversal** (Finder can move presence backwards)
- **Convergent/divergent paths** (multiple paths meeting at shared nodes)
- **True graph topology** (Finder has a web with 3 interconnected paths)
- **Modifier slots** (+Energy, +Card Plays separate from base values)

Current broken structure:
```typescript
presenceTracks: {
  layout: "branching",
  tracks: [
    { type: "energy", connectsTo: "cardPlays", connectionPoint: 3, slots: [...] },
    { type: "cardPlays", slots: [...] }
  ]
}
```

## Recommendation: Node-Edge Graph Model (Option A)

### Why Node-Edge is Best (Without BC Constraints)

| Factor | Node-Edge (A) | Adjacency (B) | Grid Hybrid (C) |
|--------|---------------|---------------|-----------------|
| **Clarity** | Explicit edges, easy to read | Edge duplication confusing | Null cells clutter |
| **Validation** | Single source of truth for edges | Must validate both directions | Implicit adjacency + explicit connections |
| **Expressiveness** | Any topology | Any topology | Grid-constrained |
| **Simple spirits** | Single-row nodes, no edges | Still needs adjacency arrays | Single row with nulls |
| **Rendering** | Position explicit in node | Position in node | Position implicit |
| **Maintainability** | Add/remove edges easily | Must update 2 places | Fragile position refs |

**Key insight:** Without backward compatibility, we can design the **ideal** data structure. Node-Edge is the canonical way to represent graphs in computer science. The previous research favored Grid Hybrid primarily because it preserved the existing track array structure.

### Design Principles

1. **Unified format** - All spirits use the same schema, simple and complex
2. **Explicit over implicit** - Edges are declared, not inferred from position
3. **Position for rendering** - Each node has explicit (row, col) for CSS Grid
4. **Rich node metadata** - Nodes carry all slot information
5. **Bidirectional default** - Most Spirit Island tracks are bidirectional

## Schema Design

### Convex Schema Validator

```typescript
// convex/schema.ts - presenceTracks field
presenceTracks: v.optional(
  v.object({
    // Grid dimensions for CSS Grid layout
    rows: v.number(),
    cols: v.number(),

    // Whether all edges are bidirectional (default: true)
    bidirectional: v.optional(v.boolean()),

    // Nodes represent presence slots
    nodes: v.array(
      v.object({
        // Unique node identifier (required)
        id: v.string(),

        // Grid position for rendering (0-indexed)
        row: v.number(),
        col: v.number(),

        // Node content
        value: v.optional(v.union(v.number(), v.string())), // 1, 2, "+1", "+2", etc.

        // What type of bonus this provides
        trackType: v.optional(
          v.union(
            v.literal("energy"),        // Base energy value
            v.literal("cardPlays"),     // Base card plays value
            v.literal("energyMod"),     // +N Energy modifier
            v.literal("cardPlaysMod"),  // +N Card Plays modifier
            v.literal("elements"),      // Element only
            v.literal("special"),       // Special ability
            v.literal("start"),         // Starting position (no value)
          )
        ),

        // Optional metadata
        elements: v.optional(v.array(v.string())),  // ["Moon", "Air"]
        reclaim: v.optional(v.boolean()),           // Reclaim One icon
        specialAbility: v.optional(v.string()),     // Custom text
        presenceCap: v.optional(v.number()),        // Serpent's limit track
        unlocksGrowth: v.optional(v.boolean()),     // Starlight's growth unlock
      })
    ),

    // Edges connect nodes
    edges: v.array(
      v.object({
        from: v.string(),  // Node ID
        to: v.string(),    // Node ID
        // Override global bidirectional setting
        bidirectional: v.optional(v.boolean()),
      })
    ),
  })
),
```

### TypeScript Types (for reference)

```typescript
type TrackType = "energy" | "cardPlays" | "energyMod" | "cardPlaysMod" | "elements" | "special" | "start";

interface PresenceNode {
  id: string;
  row: number;
  col: number;
  value?: number | string;
  trackType?: TrackType;
  elements?: string[];
  reclaim?: boolean;
  specialAbility?: string;
  presenceCap?: number;
  unlocksGrowth?: boolean;
}

interface PresenceEdge {
  from: string;
  to: string;
  bidirectional?: boolean;
}

interface PresenceTracks {
  rows: number;
  cols: number;
  bidirectional?: boolean;
  nodes: PresenceNode[];
  edges: PresenceEdge[];
}
```

## Example Data

### Simple Linear Spirit: River Surges in Sunlight

```typescript
presenceTracks: {
  rows: 2,
  cols: 7,
  bidirectional: false, // Standard linear tracks are unidirectional
  nodes: [
    // Energy track (row 0)
    { id: "e1", row: 0, col: 0, value: 1, trackType: "energy" },
    { id: "e2", row: 0, col: 1, value: 2, trackType: "energy" },
    { id: "e3", row: 0, col: 2, value: 2, trackType: "energy" },
    { id: "e4", row: 0, col: 3, value: 3, trackType: "energy" },
    { id: "e5", row: 0, col: 4, value: 4, trackType: "energy" },
    { id: "e6", row: 0, col: 5, value: 4, trackType: "energy" },
    { id: "e7", row: 0, col: 6, value: 5, trackType: "energy" },
    // Card plays track (row 1)
    { id: "c1", row: 1, col: 0, value: 1, trackType: "cardPlays" },
    { id: "c2", row: 1, col: 1, value: 2, trackType: "cardPlays" },
    { id: "c3", row: 1, col: 2, value: 2, trackType: "cardPlays" },
    { id: "c4", row: 1, col: 3, value: 3, trackType: "cardPlays" },
    { id: "c5", row: 1, col: 4, value: 3, trackType: "cardPlays", reclaim: true },
    { id: "c6", row: 1, col: 5, value: 4, trackType: "cardPlays" },
    { id: "c7", row: 1, col: 6, value: 5, trackType: "cardPlays" },
  ],
  edges: [
    // Energy track progression
    { from: "e1", to: "e2" },
    { from: "e2", to: "e3" },
    { from: "e3", to: "e4" },
    { from: "e4", to: "e5" },
    { from: "e5", to: "e6" },
    { from: "e6", to: "e7" },
    // Card plays track progression
    { from: "c1", to: "c2" },
    { from: "c2", to: "c3" },
    { from: "c3", to: "c4" },
    { from: "c4", to: "c5" },
    { from: "c5", to: "c6" },
    { from: "c6", to: "c7" },
  ],
}
```

### Complex Graph Spirit: Finder of Paths Unseen

Based on research, Finder has three interconnected paths with bidirectional traversal:

```typescript
presenceTracks: {
  rows: 3,
  cols: 8,
  bidirectional: true, // All paths allow backward movement
  nodes: [
    // Row 0: Top path (energy-focused)
    { id: "start1", row: 0, col: 0, trackType: "start" },
    { id: "range1", row: 0, col: 1, value: "+1", trackType: "special", specialAbility: "+1 Range on everything" },
    { id: "e1", row: 0, col: 2, value: 1, trackType: "energy", elements: ["Moon"] },
    { id: "e2", row: 0, col: 3, value: 1, trackType: "energy", elements: ["Air"] },
    { id: "e3", row: 0, col: 4, value: 2, trackType: "energy", elements: ["Water"] },
    { id: "e4", row: 0, col: 5, value: 2, trackType: "energy", elements: ["Sun"] },
    { id: "e5", row: 0, col: 6, value: 3, trackType: "energy", elements: ["Earth"] },
    { id: "e6", row: 0, col: 7, value: 3, trackType: "energy" },

    // Row 1: Middle path (modifiers)
    { id: "m1", row: 1, col: 3, value: "+2", trackType: "energyMod" },
    { id: "m2", row: 1, col: 4, value: "+1", trackType: "energyMod", elements: ["Air"] },
    { id: "m3", row: 1, col: 5, value: "+1", trackType: "cardPlaysMod" },
    { id: "m4", row: 1, col: 6, value: "+1", trackType: "special", specialAbility: "+1 Range" },

    // Row 2: Bottom path (card plays focused)
    { id: "start2", row: 2, col: 0, trackType: "start" },
    { id: "c1", row: 2, col: 1, value: 1, trackType: "cardPlays" },
    { id: "c2", row: 2, col: 2, value: 2, trackType: "cardPlays" },
    { id: "c3", row: 2, col: 3, value: 2, trackType: "cardPlays", reclaim: true },
    { id: "c4", row: 2, col: 4, value: 3, trackType: "cardPlays" },
    { id: "c5", row: 2, col: 5, value: 3, trackType: "cardPlays", elements: ["Plant"] },
    { id: "c6", row: 2, col: 6, value: 4, trackType: "cardPlays" },
  ],
  edges: [
    // Top path linear
    { from: "start1", to: "range1" },
    { from: "range1", to: "e1" },
    { from: "e1", to: "e2" },
    { from: "e2", to: "e3" },
    { from: "e3", to: "e4" },
    { from: "e4", to: "e5" },
    { from: "e5", to: "e6" },

    // Bottom path linear
    { from: "start2", to: "c1" },
    { from: "c1", to: "c2" },
    { from: "c2", to: "c3" },
    { from: "c3", to: "c4" },
    { from: "c4", to: "c5" },
    { from: "c5", to: "c6" },

    // Middle path connections (the web structure)
    { from: "m1", to: "m2" },
    { from: "m2", to: "m3" },
    { from: "m3", to: "m4" },

    // Cross-path connections (convergent points)
    { from: "e2", to: "m1" },   // Top to middle
    { from: "m1", to: "c3" },   // Middle to bottom
    { from: "e4", to: "m3" },   // Another top-middle connection
    { from: "m3", to: "c4" },   // Another middle-bottom connection
    { from: "e5", to: "m4" },   // Top to middle at range
    { from: "m4", to: "c6" },   // Middle to bottom at end
  ],
}
```

### Multi-Track Spirit: Serpent Slumbering Beneath the Island

Serpent has three parallel tracks including a unique "Deep Slumber" presence limit track:

```typescript
presenceTracks: {
  rows: 3,
  cols: 9,
  bidirectional: false,
  nodes: [
    // Row 0: Energy track
    { id: "e1", row: 0, col: 0, value: 1, trackType: "energy" },
    { id: "e2", row: 0, col: 1, value: 2, trackType: "energy" },
    { id: "e3", row: 0, col: 2, value: 3, trackType: "energy" },
    { id: "e4", row: 0, col: 3, value: 4, trackType: "energy", elements: ["Fire"] },
    { id: "e5", row: 0, col: 4, value: 5, trackType: "energy" },
    { id: "e6", row: 0, col: 5, value: 6, trackType: "energy", elements: ["Fire"] },
    { id: "e7", row: 0, col: 6, value: 7, trackType: "energy" },

    // Row 1: Absorbed Essence track
    { id: "a1", row: 1, col: 0, value: 0, trackType: "elements" },
    { id: "a2", row: 1, col: 1, value: 0, trackType: "elements", elements: ["Moon"] },
    { id: "a3", row: 1, col: 2, value: 0, trackType: "elements", elements: ["Earth"] },
    { id: "a4", row: 1, col: 3, value: 0, trackType: "elements", elements: ["Moon", "Earth"] },
    { id: "a5", row: 1, col: 4, value: 0, trackType: "elements", elements: ["Fire"] },
    { id: "a6", row: 1, col: 5, value: 0, trackType: "elements", elements: ["Moon", "Earth", "Fire"] },

    // Row 2: Deep Slumber (presence limit) track
    { id: "ds1", row: 2, col: 0, value: 5, trackType: "special", presenceCap: 5 },
    { id: "ds2", row: 2, col: 1, value: 6, trackType: "special", presenceCap: 6 },
    { id: "ds3", row: 2, col: 2, value: 7, trackType: "special", presenceCap: 7 },
    { id: "ds4", row: 2, col: 3, value: 8, trackType: "special", presenceCap: 8 },
    { id: "ds5", row: 2, col: 4, value: 9, trackType: "special", presenceCap: 9 },
    { id: "ds6", row: 2, col: 5, value: 10, trackType: "special", presenceCap: 10 },
    { id: "ds7", row: 2, col: 6, value: 11, trackType: "special", presenceCap: 11 },
    { id: "ds8", row: 2, col: 7, value: 12, trackType: "special", presenceCap: 12 },
    { id: "ds9", row: 2, col: 8, value: 13, trackType: "special", presenceCap: 13 },
  ],
  edges: [
    // Energy track
    { from: "e1", to: "e2" }, { from: "e2", to: "e3" }, { from: "e3", to: "e4" },
    { from: "e4", to: "e5" }, { from: "e5", to: "e6" }, { from: "e6", to: "e7" },
    // Absorbed track
    { from: "a1", to: "a2" }, { from: "a2", to: "a3" }, { from: "a3", to: "a4" },
    { from: "a4", to: "a5" }, { from: "a5", to: "a6" },
    // Deep Slumber track
    { from: "ds1", to: "ds2" }, { from: "ds2", to: "ds3" }, { from: "ds3", to: "ds4" },
    { from: "ds4", to: "ds5" }, { from: "ds5", to: "ds6" }, { from: "ds6", to: "ds7" },
    { from: "ds7", to: "ds8" }, { from: "ds8", to: "ds9" },
  ],
}
```

## Rendering Approach

### CSS Grid Layout

Use CSS Grid with explicit row/col positioning:

```typescript
// GridPresenceTrack.tsx
function GridPresenceTrack({ presenceTracks }: Props) {
  const { rows, cols, nodes, edges } = presenceTracks;

  return (
    <div
      className="grid gap-2"
      style={{
        gridTemplateRows: `repeat(${rows}, 1fr)`,
        gridTemplateColumns: `repeat(${cols}, minmax(44px, 1fr))`,
      }}
    >
      {nodes.map(node => (
        <PresenceNode
          key={node.id}
          node={node}
          style={{
            gridRow: node.row + 1,
            gridColumn: node.col + 1,
          }}
        />
      ))}
      <EdgeOverlay edges={edges} nodes={nodes} />
    </div>
  );
}
```

### Edge Visualization

For non-adjacent connections (Finder's cross-path links), render SVG lines between nodes:

```typescript
function EdgeOverlay({ edges, nodes }: Props) {
  // Filter to non-adjacent edges (adjacent = same row, col diff 1)
  const nonAdjacentEdges = edges.filter(edge => {
    const from = nodes.find(n => n.id === edge.from);
    const to = nodes.find(n => n.id === edge.to);
    if (!from || !to) return false;
    const isHorizontalAdjacent = from.row === to.row && Math.abs(from.col - to.col) === 1;
    return !isHorizontalAdjacent;
  });

  return (
    <svg className="absolute inset-0 pointer-events-none">
      {nonAdjacentEdges.map(edge => (
        <ConnectionLine key={`${edge.from}-${edge.to}`} edge={edge} nodes={nodes} />
      ))}
    </svg>
  );
}
```

### Connection Line Styling

- **Bidirectional edges**: Double-headed arrow or no arrows
- **Unidirectional edges**: Single arrow pointing to destination
- **Cross-track connections**: Dashed or different color to distinguish from linear progression

## Architecture Patterns

### Component Structure

```
app/components/spirits/
├── presence-track.tsx        # Entry point - detects format, delegates
├── graph-presence-track.tsx  # New graph-based renderer
├── presence-node.tsx         # Single node/slot (rename from presence-slot)
├── edge-overlay.tsx          # SVG edge visualization
└── track-label.tsx           # Track type labels
```

### Data Flow

```
Spirit data (Convex)
  → presenceTracks object
  → PresenceTrack component
  → GraphPresenceTrack renderer
  → CSS Grid + SVG edges
```

## Migration Strategy

Since backward compatibility is NOT required:

1. **Update schema** - Replace old presenceTracks definition with new graph-based one
2. **Update seed.ts** - Convert all spirits to new format
3. **Create new renderer** - Build GraphPresenceTrack component
4. **Remove old code** - Delete linear track rendering logic
5. **Run reseed** - `npx convex run seed:reseedSpirits`

### Conversion Guide

| Old Format | New Format |
|------------|------------|
| `tracks: [{ type, slots }]` | `nodes: [...], edges: [...]` |
| `slot.value` | `node.value` + `node.trackType` |
| `track.connectsTo` | Explicit edges between node IDs |
| `layout: "branching"` | Remove - edges define topology |

## Don't Hand-Roll

| Problem | Don't Build | Use Instead |
|---------|-------------|-------------|
| Graph data structure | Custom adjacency management | Simple nodes + edges arrays |
| SVG line calculations | Manual coordinate math | CSS calc() with known grid positions |
| Bidirectional handling | Duplicated edges | Single edge with `bidirectional: true` |

## Common Pitfalls

### Pitfall 1: Inconsistent Node IDs
**What goes wrong:** Edges reference non-existent nodes
**How to avoid:** TypeScript type checking, runtime validation in seed function
**Warning signs:** Edges rendered to wrong positions or not at all

### Pitfall 2: Grid Position Collisions
**What goes wrong:** Two nodes at same (row, col)
**How to avoid:** Validate unique positions in seed data
**Warning signs:** Overlapping nodes in UI

### Pitfall 3: Edge Rendering Z-Index
**What goes wrong:** Edges appear above nodes
**How to avoid:** SVG overlay with `pointer-events-none`, proper z-indexing
**Warning signs:** Can't click nodes, visual clutter

## Open Questions

1. **Exact Finder layout**: The research found general principles but not the precise slot-by-slot layout. Need to verify against actual game board image.

2. **Starlight's 6 tracks**: The wiki describes 6 tracks but with different structure than Finder. May need special handling for the 2x3 or 3x2 track arrangement.

3. **Energy calculation display**: Should the UI show calculated totals (highest base + modifiers) or leave that to player?

## Sources

### Primary (HIGH confidence)
- [Convex Schema Validators](https://docs.convex.dev/database/schemas) - Validator syntax verified
- [Spirit Island FAQ - Presence Track](https://querki.net/raw/darker/spirit-island-faq/Presence+track) - Game rules for energy calculation

### Secondary (MEDIUM confidence)
- [Spirit Island Wiki - Finder](https://spiritislandwiki.com/index.php?title=Finder_of_Paths_Unseen) - General spirit info, no detailed track layout
- [spirit-island-template](https://github.com/Gudradain/spirit-island-template/blob/master/_docs/board_front.md) - Alternative implementation approach

### Tertiary (LOW confidence)
- Web searches for exact track layouts - Need verification against physical game boards

## Metadata

**Confidence breakdown:**
- Schema design: HIGH - Convex validators well documented
- Graph model recommendation: HIGH - Standard CS pattern, clear tradeoffs
- Example data accuracy: MEDIUM - Based on rules, need board verification
- Rendering approach: HIGH - CSS Grid is standard for this use case

**Research date:** 2026-01-27
**Valid until:** 2026-02-27 (stable domain, no external dependencies)

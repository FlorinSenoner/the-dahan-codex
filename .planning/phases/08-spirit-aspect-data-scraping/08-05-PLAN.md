---
phase: 08-spirit-aspect-data-scraping
plan: 05
type: execute
wave: 3
depends_on: ["08-04"]
files_modified:
  - convex/seed.ts
  - convex/openings.ts
autonomous: true

must_haves:
  truths:
    - "reseedSpirits mutation preserves existing openings"
    - "User-created openings are not deleted when reseeding spirits"
    - "Seed openings are re-created if missing, existing user openings remain"
  artifacts:
    - path: "convex/seed.ts"
      provides: "Updated reseed logic with opening preservation"
      contains: "preserveOpenings|backupOpenings"
    - path: "convex/openings.ts"
      provides: "Opening backup/restore helpers"
  key_links:
    - from: "convex/seed.ts"
      to: "convex/openings.ts"
      via: "import { backupOpenings, restoreOpenings }"
      pattern: "from.*openings"
---

<objective>
Fix the reseedSpirits mutation to preserve user-created openings when reseeding spirit data.

Purpose: Allow data updates without losing user-contributed opening guides.
Output: reseedSpirits that backs up and restores openings during reseed.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-spirit-aspect-data-scraping/08-RESEARCH.md
@convex/seed.ts
@convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Design opening preservation strategy</name>
  <files>convex/seed.ts</files>
  <action>
The problem: Current reseedSpirits deletes ALL openings including user-created ones.

Solution: Backup openings by spirit slug before delete, restore after seeding.

1. Before clearing data:
   - Query all openings
   - For each opening, store the spirit's slug (not ID, since IDs will change)
   - Store the full opening data in memory

2. After seeding spirits:
   - For each backed-up opening, look up new spirit ID by slug
   - Re-insert the opening with the new spiritId
   - Skip if spirit no longer exists (edge case)

3. Handle seed openings vs user openings:
   - Seed openings have author: "Spirit Island Community" or are in SEED_OPENINGS
   - Mark seed openings in backup to avoid duplicates
   - When restoring: if it's a seed opening and already exists, skip

This approach:
- Preserves ALL openings (user and seed)
- Handles spirit ID changes during reseed
- Is idempotent (running twice doesn't create duplicates)
  </action>
  <verify>Design documented in code comments</verify>
  <done>Opening preservation strategy designed and documented</done>
</task>

<task type="auto">
  <name>Task 2: Implement backup and restore in seed.ts</name>
  <files>convex/seed.ts</files>
  <action>
Update clearExistingData and reseedSpirits in convex/seed.ts:

1. Add backup function:
```typescript
interface OpeningBackup {
  spiritSlug: string;  // Look up spirit by slug after reseed
  data: Omit<Doc<"openings">, "_id" | "_creationTime" | "spiritId">;
  isSeedOpening: boolean;
}

async function backupOpenings(ctx: MutationCtx): Promise<OpeningBackup[]> {
  const openings = await ctx.db.query("openings").collect();
  const backups: OpeningBackup[] = [];

  for (const opening of openings) {
    const spirit = await ctx.db.get(opening.spiritId);
    if (!spirit) continue;

    const { _id, _creationTime, spiritId, ...data } = opening;
    backups.push({
      spiritSlug: spirit.slug,
      data,
      isSeedOpening: opening.author === "Spirit Island Community",
    });
  }

  return backups;
}
```

2. Add restore function:
```typescript
async function restoreOpenings(
  ctx: MutationCtx,
  backups: OpeningBackup[],
  spiritIdsBySlug: Map<string, Id<"spirits">>
): Promise<{ restored: number; skipped: number }> {
  let restored = 0;
  let skipped = 0;

  for (const backup of backups) {
    const spiritId = spiritIdsBySlug.get(backup.spiritSlug);
    if (!spiritId) {
      skipped++;
      continue;
    }

    // Check if opening with same slug already exists for this spirit
    const existing = await ctx.db
      .query("openings")
      .withIndex("by_slug", q => q.eq("slug", backup.data.slug))
      .first();

    if (existing) {
      skipped++;
      continue;
    }

    await ctx.db.insert("openings", {
      spiritId,
      ...backup.data,
    });
    restored++;
  }

  return { restored, skipped };
}
```

3. Update reseedSpirits handler:
```typescript
export const reseedSpirits = mutation({
  handler: async (ctx) => {
    // Backup openings before clearing
    const openingBackups = await backupOpenings(ctx);

    // Clear existing data
    await clearExistingData(ctx);

    // Seed new data and get spirit ID map
    const { spiritIdsBySlug } = await insertSeedData(ctx);

    // Restore openings
    const { restored, skipped } = await restoreOpenings(ctx, openingBackups, spiritIdsBySlug);

    return {
      status: "reseeded",
      message: `Deleted and recreated data. Openings: ${restored} restored, ${skipped} skipped`,
    };
  },
});
```

4. Update insertSeedData to return spiritIdsBySlug map
  </action>
  <verify>
TypeScript compiles: npx convex dev --once
Run local test with mock data to verify backup/restore
  </verify>
  <done>reseedSpirits backs up and restores openings during reseed</done>
</task>

<task type="auto">
  <name>Task 3: Test preservation with existing data</name>
  <files>convex/seed.ts</files>
  <action>
Test the opening preservation locally:

1. Start local Convex dev server:
   ```bash
   npx convex dev
   ```

2. Create a test opening via dashboard or CLI to simulate user data:
   - Go to Convex dashboard
   - Insert a new opening for River with different slug

3. Run reseedSpirits:
   ```bash
   npx convex run seed:reseedSpirits
   ```

4. Verify in dashboard:
   - All spirits reseeded (check count)
   - Original River opening still exists
   - Test opening still exists with correct spiritId reference
   - No duplicate openings

5. Run again to test idempotency:
   - Should see same state after second run
   - No duplicates created

6. Update return message to show accurate counts
  </action>
  <verify>
Run: npx convex run seed:reseedSpirits
Check: Openings preserved after reseed (verify in dashboard)
Run again: npx convex run seed:reseedSpirits (verify no duplicates)
  </verify>
  <done>Opening preservation verified working correctly</done>
</task>

</tasks>

<verification>
1. reseedSpirits compiles without TypeScript errors
2. Running reseedSpirits preserves existing openings
3. Openings correctly reference new spirit IDs after reseed
4. No duplicate openings created on repeated reseed
5. Return message shows accurate restoration counts
</verification>

<success_criteria>
- User-created openings survive reseedSpirits mutation
- Seed openings re-created correctly
- No data loss during spirit data updates
- Mutation is idempotent
</success_criteria>

<output>
After completion, create `.planning/phases/08-spirit-aspect-data-scraping/08-05-SUMMARY.md`
</output>

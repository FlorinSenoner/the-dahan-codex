# Phase 3.2: Spirit Board Refinements - Research

**Researched:** 2026-01-27
**Domain:** UI/UX refinements, complex spirit board patterns, CSS subgrid, scroll detection
**Confidence:** HIGH

## Summary

This phase addresses 13 UAT gaps from Phase 3.1, focusing on UI refinements and adding support for complex spirits. Research identified five major workstreams: (1) minimalist aspect navigation with scroll-aware header updates, (2) growth panel redesign with CSS subgrid for equal-size cards and neutral colors, (3) presence track support for 3+ tracks and connected/overlapping patterns, (4) innate powers and cards redesign with border-only speed indicators, and (5) seed data for four complex spirits demonstrating all patterns.

The key technical challenges are implementing Intersection Observer-based scroll detection for the aspect name header display, CSS subgrid for equal-height growth action cards, and schema extensions for complex spirit patterns (Fractured Days' choose-from-multiple growth, Starlight's multi-track presence, Finder's branching tracks, Serpent's Deep Slumber mechanic).

**Primary recommendation:** Use `react-intersection-observer` for scroll detection, Tailwind v4's native `grid-rows-subgrid` for equal-size growth cards, and extend the existing schema to support complex spirit patterns rather than creating new schema types.

## Standard Stack

The established libraries/tools for this phase:

### Core (Adding)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| react-intersection-observer | ^10.0.0+ | Scroll position detection | Most popular React wrapper for Intersection Observer API, tiny bundle (~1.15kB) |

### Core (Already in Project)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Tailwind CSS | 4.1.x | CSS subgrid utilities | Native `grid-rows-subgrid` support since v3.4, CSS-first in v4 |
| Radix Tabs | 1.1.13 | Aspect navigation | Already integrated with shadcn/ui |
| Radix Accordion | 1.2.12 | Collapsible sections | Hand/discard section collapse |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| react-intersection-observer | Native IntersectionObserver | More boilerplate, no React integration |
| CSS subgrid | Flexbox with explicit heights | More complex, less maintainable |
| Border-based speed | Badge-based speed | Current approach, more visual noise |

**Installation:**
```bash
pnpm add react-intersection-observer
```

## Architecture Patterns

### Recommended Project Structure
```
app/
├── components/
│   ├── spirits/
│   │   ├── variant-tabs.tsx        # Minimalist tabs with scroll detection
│   │   ├── growth-panel.tsx        # CSS subgrid, neutral colors, tooltips
│   │   ├── presence-track.tsx      # 3+ tracks, spirit-specific colors
│   │   ├── innate-powers.tsx       # Border-only speed, single-line layout
│   │   ├── card-hand.tsx           # Hand/discard sections, border-only speed
│   │   └── overview-section.tsx    # Pills extraction, collapsible description
│   └── icons/
│       └── growth/                 # Existing growth icons (neutral colors)
├── lib/
│   └── spirit-colors.ts           # Add spirit-specific presence track colors
convex/
├── schema.ts                      # Schema for complex growth types
└── seed.ts                        # Add 4 complex spirits
```

### Pattern 1: Scroll-Aware Header with useInView
**What:** Detect when aspect tabs scroll behind header, update header text
**When to use:** Aspect navigation with sticky behavior
**Example:**
```typescript
// Source: react-intersection-observer docs
import { useInView } from "react-intersection-observer";

function VariantTabs({ base, aspects }: VariantTabsProps) {
  const { ref: tabsRef, inView: tabsVisible } = useInView({
    threshold: 0,
    rootMargin: "-57px 0px 0px 0px", // Header height offset
  });

  // Pass tabsVisible to parent via callback/context
  // When !tabsVisible, show aspect name in header

  return (
    <Tabs>
      <TabsList ref={tabsRef} className="sticky top-[57px]">
        {/* ... tabs */}
      </TabsList>
    </Tabs>
  );
}
```

### Pattern 2: CSS Subgrid for Equal-Size Growth Cards
**What:** Use subgrid to ensure all growth option cards have equal height
**When to use:** Growth panel with variable content lengths
**Example:**
```typescript
// Source: Tailwind CSS docs, MDN Subgrid Guide
// Parent defines row template, children inherit via subgrid
<div className="grid grid-cols-1 sm:grid-cols-3 gap-3">
  {options.map((option) => (
    <div
      key={option.id}
      className="grid grid-rows-subgrid row-span-2 gap-2 bg-muted/30 rounded-lg p-3"
    >
      {/* Row 1: Actions */}
      <div className="flex flex-wrap gap-2">
        {option.actions.map(action => <GrowthActionIcon action={action} />)}
      </div>
      {/* Row 2: Labels (hover-revealed) */}
      <div className="opacity-0 group-hover:opacity-100 transition-opacity">
        {option.id}
      </div>
    </div>
  ))}
</div>
```

### Pattern 3: Spirit-Specific Presence Track Colors
**What:** Map spirits to unique color palettes based on primary elements
**When to use:** Presence tracks that reflect spirit identity
**Example:**
```typescript
// Source: Spirit Island element color mapping
// Spirit-specific colors derived from primary elements
export const spiritTrackColors: Record<string, {
  primary: string;
  secondary: string;
}> = {
  "river-surges-in-sunlight": {
    primary: "cyan",     // Water-based
    secondary: "amber",  // Sun-based
  },
  "lightnings-swift-strike": {
    primary: "orange",   // Fire-based
    secondary: "violet", // Air-based
  },
  "fractured-days-split-the-sky": {
    primary: "indigo",   // Moon-based
    secondary: "amber",  // Air-based
  },
  // ... more spirits
};

// Gradient classes
const spiritGradients: Record<string, string> = {
  cyan: "bg-gradient-to-r from-cyan-500/15 via-cyan-500/5 to-transparent",
  orange: "bg-gradient-to-r from-orange-500/15 via-orange-500/5 to-transparent",
  indigo: "bg-gradient-to-r from-indigo-500/15 via-indigo-500/5 to-transparent",
  violet: "bg-gradient-to-r from-violet-500/15 via-violet-500/5 to-transparent",
  // ... more colors
};
```

### Pattern 4: Complex Growth Schema Extensions
**What:** Schema changes to support Fractured Days' choose-from-multiple pattern
**When to use:** Spirits with non-standard growth (pick-2-of-4, or-options)
**Example:**
```typescript
// Source: Spirit Island Wiki - Fractured Days Split the Sky
// Extended growth schema for complex patterns
growth: v.optional(
  v.object({
    type: v.optional(v.union(
      v.literal("pick-one"),
      v.literal("pick-two"),
      v.literal("pick-any")  // New: for Fractured Days
    )),
    options: v.array(
      v.object({
        id: v.string(),
        cost: v.optional(v.number()),
        // New: or-options for Fractured Days' "gain 1 Time OR 2 Card Plays"
        orActions: v.optional(v.array(
          v.object({
            label: v.string(),  // "1 Time" or "2 Card Plays"
            actions: v.array(/* action objects */),
          })
        )),
        // Existing: standard actions
        actions: v.array(/* action objects */),
        // New: repeat count for "do this N times"
        repeat: v.optional(v.number()),
      }),
    ),
  }),
),
```

### Pattern 5: Branching/Connected Presence Tracks
**What:** Schema and UI for Finder's branching tracks, Starlight's multi-tracks
**When to use:** Complex spirits with non-linear presence progression
**Example:**
```typescript
// Source: Spirit Island Wiki - Finder of Paths Unseen, Starlight
// Track with optional connections
presenceTracks: v.optional(
  v.object({
    layout: v.optional(v.union(
      v.literal("linear"),     // Standard: left-to-right
      v.literal("branching"),  // Finder: paths with connections
      v.literal("multiple")    // Starlight: 4+ independent tracks
    )),
    tracks: v.array(
      v.object({
        type: v.string(),
        label: v.string(),
        color: v.optional(v.string()),
        // New: track can be connected to another track
        connectsTo: v.optional(v.string()), // Track ID
        connectionPoint: v.optional(v.number()), // Slot index
        // New: track unlocks growth options (Starlight)
        unlocksGrowth: v.optional(v.boolean()),
        slots: v.array(/* slot objects */),
      }),
    ),
  }),
),
```

### Anti-Patterns to Avoid
- **Gradient tabs:** Don't use gradient backgrounds on tabs; prefer flat minimalist style
- **Scroll listeners:** Don't use scroll event listeners; use Intersection Observer for performance
- **Fixed height cards:** Don't set explicit heights on growth cards; use CSS subgrid
- **Badge-based speed:** Don't use badges for Fast/Slow; use border color only
- **Generic track colors:** Don't use same amber/blue for all spirits; use spirit-specific palettes

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Scroll detection | scroll event listener + state | react-intersection-observer | Async, performant, no jank |
| Equal card heights | Flexbox with min-height | CSS subgrid | Automatic, inherits parent sizing |
| Collapsible sections | CSS height transitions | Radix Collapsible/Accordion | Accessibility, proper ARIA |
| Speed indicators | Badge + text label | Border color (2px solid) | Less visual noise, consistent with cards |
| Complex growth parsing | String parsing | Typed schema with discriminated unions | Type safety, no runtime errors |

**Key insight:** CSS subgrid is now baseline (Sep 2023) with full browser support. Use it over complex flexbox workarounds for equal-height layouts.

## Common Pitfalls

### Pitfall 1: Intersection Observer Root Margin Sign
**What goes wrong:** Tabs not detected when scrolled behind header
**Why it happens:** Forgetting that negative rootMargin shrinks the detection area
**How to avoid:** Use negative top margin equal to header height:
```typescript
const { ref, inView } = useInView({
  rootMargin: "-57px 0px 0px 0px", // Negative = shrink from top
});
```
**Warning signs:** inView still true when tabs are behind header

### Pitfall 2: Subgrid Row Span Mismatch
**What goes wrong:** Cards not aligning, subgrid ineffective
**Why it happens:** Child `row-span` doesn't match parent's implicit row count
**How to avoid:** Define explicit row count on parent, match with child span:
```typescript
// Parent: 3 growth options, each has 2 rows (content + label)
<div className="grid grid-cols-3 grid-rows-[auto_auto]">
  {/* Child spans all defined rows */}
  <div className="row-span-2 grid grid-rows-subgrid">
```
**Warning signs:** Cards jumping to different heights on content change

### Pitfall 3: Sticky Z-Index Layering
**What goes wrong:** Tabs appear above header when scrolled
**Why it happens:** Both have position: sticky, same z-index
**How to avoid:** Header z-20, tabs z-10 (lower than header):
```typescript
// Header
<header className="sticky top-0 z-20">

// Tabs
<TabsList className="sticky top-[57px] z-10">
```
**Warning signs:** Tabs visually overlap header during scroll

### Pitfall 4: Spirit-Specific Colors Not Falling Back
**What goes wrong:** Spirits without color mapping show no styling
**Why it happens:** Missing fallback in lookup
**How to avoid:** Always provide default:
```typescript
const colors = spiritTrackColors[spirit.slug] ?? {
  primary: "amber",
  secondary: "blue",
};
```
**Warning signs:** New spirits show unstyled (no gradient) presence tracks

### Pitfall 5: Complex Growth Data Incompatible with Schema
**What goes wrong:** Fractured Days data fails validation
**Why it happens:** Schema doesn't support or-options
**How to avoid:** Extend schema incrementally:
1. Add optional fields (orActions, repeat)
2. Update type guards to handle both formats
3. Test with River (simple) and Fractured Days (complex)
**Warning signs:** Convex runtime errors on seed data

## Code Examples

Verified patterns from official sources:

### useInView for Header Updates
```typescript
// Source: react-intersection-observer GitHub
// https://github.com/thebuilder/react-intersection-observer
import { useInView } from "react-intersection-observer";
import { createContext, useContext } from "react";

// Context for passing scroll state to header
const AspectScrollContext = createContext<{
  aspectName: string | null;
  tabsVisible: boolean;
}>({ aspectName: null, tabsVisible: true });

function VariantTabsWithScroll({ base, aspects, currentAspect }: Props) {
  const { ref, inView } = useInView({
    threshold: 0,
    rootMargin: "-57px 0px 0px 0px",
  });

  return (
    <AspectScrollContext.Provider
      value={{
        aspectName: currentAspect || null,
        tabsVisible: inView,
      }}
    >
      <Tabs>
        <TabsList
          ref={ref}
          className="sticky top-[57px] z-10 w-full bg-background/95 backdrop-blur border-b border-border"
        >
          {/* Remove gradient, use flat border-b-2 for active */}
          <TabsTrigger
            value="base"
            className="min-h-[44px] border-b-2 border-transparent data-[state=active]:border-primary"
          >
            Base
          </TabsTrigger>
          {aspects.map((a) => (
            <TabsTrigger key={a.aspectName} value={a.aspectName?.toLowerCase()}>
              {a.aspectName}
            </TabsTrigger>
          ))}
        </TabsList>
      </Tabs>
    </AspectScrollContext.Provider>
  );
}

// In header component
function SpiritHeader({ spiritName }: { spiritName: string }) {
  const { aspectName, tabsVisible } = useContext(AspectScrollContext);

  return (
    <header className="sticky top-0 z-20">
      <span className="font-serif text-lg">
        {!tabsVisible && aspectName ? aspectName : spiritName}
      </span>
    </header>
  );
}
```

### CSS Subgrid Growth Cards
```typescript
// Source: MDN Subgrid, Tailwind docs
// https://developer.mozilla.org/en-US/docs/Web/CSS/Guides/Grid_layout/Subgrid
function GrowthPanel({ growth }: { growth: GrowthData }) {
  return (
    <section className="space-y-3">
      <Heading variant="h3">Growth</Heading>

      {/* Parent grid defines row template */}
      <div className="grid grid-cols-1 sm:grid-cols-3 gap-3">
        {growth.options.map((option) => (
          <div
            key={option.id}
            className={cn(
              // Subgrid inherits row sizing from parent
              "row-span-2 grid grid-rows-subgrid gap-2",
              "bg-muted/30 rounded-lg p-3 group relative"
            )}
          >
            {/* Row 1: Action icons with tooltips */}
            <div className="flex flex-wrap gap-2 items-center">
              {option.actions.map((action, idx) => (
                <Tooltip key={`${option.id}-${action.type}-${idx}`}>
                  <TooltipTrigger>
                    <GrowthIcon
                      type={action.type}
                      className="w-8 h-8 text-muted-foreground"
                    />
                  </TooltipTrigger>
                  <TooltipContent>
                    {formatGrowthAction(action)}
                  </TooltipContent>
                </Tooltip>
              ))}
            </div>

            {/* Row 2: Option ID (hover reveal) */}
            <div className="text-xs text-muted-foreground opacity-0 group-hover:opacity-100 transition-opacity">
              {option.id}
            </div>
          </div>
        ))}
      </div>
    </section>
  );
}
```

### Minimalist Tab Styling (No Gradient)
```typescript
// Remove gradient, use simple border indicator
const tabTriggerClassName = cn(
  "min-w-fit min-h-[44px] shrink-0 cursor-pointer",
  "rounded-none",  // Flat edges
  "border-b-2 border-transparent",  // Inactive: transparent border
  "data-[state=active]:border-primary",  // Active: colored border only
  "data-[state=active]:text-foreground",  // Active: full text color
  "text-muted-foreground",  // Inactive: muted text
  "hover:text-foreground transition-colors"
);
```

### Border-Only Speed for Innates
```typescript
// Source: UAT feedback - single line, border color only
function InnatePowerHeader({ innate }: { innate: Innate }) {
  return (
    <div
      className={cn(
        "border-l-4 pl-3 py-1",
        innate.speed === "Fast" ? "border-amber-500" : "border-blue-500"
      )}
    >
      <div className="flex items-center gap-2 flex-wrap">
        {/* Name */}
        <span className="font-medium">{innate.name}</span>

        {/* Elements + effect on same line */}
        <ElementThreshold elements={innate.thresholds[0].elements} />

        {/* Range/Target inline */}
        {innate.range && (
          <span className="text-xs text-muted-foreground">
            R: {innate.range}
          </span>
        )}
        {innate.target && (
          <span className="text-xs text-muted-foreground">
            T: {innate.target}
          </span>
        )}
      </div>
    </div>
  );
}
```

### Spirit-Specific Track Colors
```typescript
// Map spirit slugs to element-derived colors
export const spiritTrackColors: Record<string, {
  energy: string;
  cardPlays: string;
}> = {
  // Water/Sun spirits
  "river-surges-in-sunlight": {
    energy: "cyan",      // Water primary
    cardPlays: "amber",  // Sun secondary
  },
  // Fire/Air spirits
  "lightnings-swift-strike": {
    energy: "orange",    // Fire primary
    cardPlays: "violet", // Air secondary
  },
  // Moon/Air spirits
  "fractured-days-split-the-sky": {
    energy: "indigo",    // Moon primary
    cardPlays: "violet", // Air secondary
  },
  // Moon spirits
  "starlight-seeks-its-form": {
    energy: "indigo",    // Moon primary
    cardPlays: "amber",  // Sun secondary
  },
  // Air spirits
  "finder-of-paths-unseen": {
    energy: "violet",    // Air primary
    cardPlays: "emerald", // Plant secondary
  },
  // Fire/Earth spirits
  "serpent-slumbering-beneath-the-island": {
    energy: "orange",    // Fire primary
    cardPlays: "stone",  // Earth secondary
  },
};

// Fallback for spirits without explicit mapping
export function getSpiritTrackColors(slug: string) {
  return spiritTrackColors[slug] ?? {
    energy: "amber",
    cardPlays: "blue",
  };
}

// Gradient classes
export const trackGradientClasses: Record<string, string> = {
  amber: "bg-gradient-to-r from-amber-500/15 via-amber-500/5 to-transparent",
  blue: "bg-gradient-to-r from-blue-500/15 via-blue-500/5 to-transparent",
  cyan: "bg-gradient-to-r from-cyan-500/15 via-cyan-500/5 to-transparent",
  orange: "bg-gradient-to-r from-orange-500/15 via-orange-500/5 to-transparent",
  violet: "bg-gradient-to-r from-violet-500/15 via-violet-500/5 to-transparent",
  indigo: "bg-gradient-to-r from-indigo-500/15 via-indigo-500/5 to-transparent",
  emerald: "bg-gradient-to-r from-emerald-500/15 via-emerald-500/5 to-transparent",
  stone: "bg-gradient-to-r from-stone-500/15 via-stone-500/5 to-transparent",
};
```

## Complex Spirit Board Patterns

### Fractured Days Split the Sky
**Growth:** Choose-from-4 with or-options (e.g., "gain 1 Time OR 2 Card Plays x2")
**Presence:** Standard 2 tracks
**Unique mechanic:** Time tokens, Days That Never Were card pool

Schema requirements:
- `orActions` array for alternative choices within a growth option
- `repeat` number for "do N times" options
- Special action type "gainTime" for Time token mechanics

### Starlight Seeks Its Form
**Growth:** 4 of 6 presence tracks unlock growth choices
**Presence:** 6 tracks total, 4 connected to growth choices
**Unique mechanic:** "Growth Begets Growth" - emptying tracks reveals choices

Schema requirements:
- `unlocksGrowth` boolean on tracks
- `growthChoices` array associated with tracks
- Track `layout: "multiple"` for non-standard display

### Finder of Paths Unseen
**Growth:** Standard pick-one
**Presence:** Branching paths from 2 starting points
**Unique mechanic:** Can travel backwards along paths

Schema requirements:
- Track `layout: "branching"`
- `connectsTo` and `connectionPoint` for path connections
- Visual representation of branching layout

### Serpent Slumbering Beneath the Island
**Growth:** Standard pick-one
**Presence:** 2 tracks + Deep Slumber limit track (5-13)
**Unique mechanic:** Presence limit increases via Absorb Essence card

Schema requirements:
- Special track type "presenceLimit" for Deep Slumber
- `presenceCap` slot property for limit values
- Track styling distinct from energy/cardPlays

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Gradient tab highlight | Border-only indicator | UAT feedback 2026 | Cleaner, less visual noise |
| Scroll event listeners | Intersection Observer | 2019+ | 60fps, no jank, async |
| Flexbox equal heights | CSS subgrid | Baseline Sep 2023 | Automatic, inherits parent |
| Generic track colors | Spirit-specific palettes | Phase 3.2 | Stronger spirit identity |
| Badge speed indicators | Border color speed | UAT feedback 2026 | Consistent with game cards |

**Deprecated/outdated:**
- Using `scroll` event for visibility detection: Replace with Intersection Observer
- Using flexbox hacks for equal-height cards: Replace with CSS subgrid
- Gradient backgrounds on tab triggers: Replace with border-only active state

## Open Questions

Things that couldn't be fully resolved:

1. **Finder branching track visual representation**
   - What we know: Tracks can branch and connect, with bidirectional traversal
   - What's unclear: Best SVG/CSS approach for showing branching paths on mobile
   - Recommendation: Start with linear display, add visual connections later

2. **Starlight 6-track layout**
   - What we know: 4 tracks unlock growth choices when emptied
   - What's unclear: Mobile layout for 6 tracks + growth choice indicators
   - Recommendation: Stack tracks vertically, show growth unlock as badge/icon

3. **Fractured Days "Days That Never Were" pool**
   - What we know: Special card pool created at setup
   - What's unclear: Whether to represent in schema or just in special rules
   - Recommendation: Add as special rule text, don't model card pool in schema

4. **Conditional aspect tab rendering**
   - What we know: Tabs should only show for spirits with 1+ aspects
   - What's unclear: Best approach for base-only spirits (no tabs vs disabled tab)
   - Recommendation: Hide entire tab bar when aspects.length === 0

## Sources

### Primary (HIGH confidence)
- [MDN Subgrid Guide](https://developer.mozilla.org/en-US/docs/Web/CSS/Guides/Grid_layout/Subgrid) - CSS subgrid patterns
- [Tailwind CSS Grid Docs](https://tailwindcss.com/docs/grid-template-columns) - `grid-cols-subgrid`, `grid-rows-subgrid` utilities
- [react-intersection-observer GitHub](https://github.com/thebuilder/react-intersection-observer) - useInView API
- [Spirit Island Wiki - Fractured Days](https://spiritislandwiki.com/index.php?title=Fractured_Days_Split_the_Sky) - Growth patterns
- [Spirit Island Wiki - Starlight](https://spiritislandwiki.com/index.php?title=Starlight_Seeks_Its_Form) - Multi-track presence
- [Spirit Island Wiki - Finder](https://spiritislandwiki.com/index.php?title=Finder_of_Paths_Unseen) - Branching tracks
- [Spirit Island Wiki - Serpent](https://spiritislandwiki.com/index.php?title=Serpent_Slumbering_Beneath_the_Island) - Deep Slumber mechanic

### Secondary (MEDIUM confidence)
- [LogRocket - Dynamic Headers](https://blog.logrocket.com/using-react-intersection-observer-create-dynamic-header/) - Scroll-aware header patterns
- [Builder.io - React Intersection Observer](https://www.builder.io/blog/react-intersection-observer) - useInView best practices
- [Steve Kinney - Grid Subgrids](https://stevekinney.com/courses/tailwind/grid-subgrids) - Tailwind subgrid tutorial

### Tertiary (LOW confidence)
- BoardGameGeek discussions - Spirit element color associations
- Spirit Island community - Custom presence token colors

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - react-intersection-observer well documented, CSS subgrid is baseline
- Architecture: HIGH - Patterns verified with official docs and existing codebase
- Complex spirits: MEDIUM - Wiki data confirmed, schema extensions need implementation testing
- Pitfalls: HIGH - Based on UAT feedback and known CSS subgrid limitations

**Research date:** 2026-01-27
**Valid until:** 2026-02-26 (30 days - stable domain, UI patterns don't change frequently)

---
phase: 05-text-opening-management
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - app/components/admin/opening-form.tsx
  - app/lib/schemas/opening.ts
autonomous: true

must_haves:
  truths:
    - "Form validates name is required"
    - "Form validates slug matches lowercase-hyphen pattern"
    - "Form validates at least one turn exists"
    - "Form validates instructions required for each turn"
    - "useFieldArray manages dynamic turn list with add/remove"
    - "Each turn field uses field.id as React key (not array index)"
  artifacts:
    - path: "app/lib/schemas/opening.ts"
      provides: "Zod schema for opening form validation"
      exports: ["openingFormSchema", "OpeningFormData"]
    - path: "app/components/admin/opening-form.tsx"
      provides: "Reusable opening form with dynamic turns"
      exports: ["OpeningForm"]
  key_links:
    - from: "app/components/admin/opening-form.tsx"
      to: "app/lib/schemas/opening.ts"
      via: "zodResolver import"
      pattern: "zodResolver\\(openingFormSchema\\)"
    - from: "app/components/admin/opening-form.tsx"
      to: "react-hook-form"
      via: "useFieldArray hook"
      pattern: "useFieldArray.*name.*turns"
---

<objective>
Create the opening form component with Zod validation and dynamic turn management.

Purpose: Build a reusable form component that handles opening creation and editing. The form uses useFieldArray for dynamic turn management and Zod for validation. This component will be used by both the create and edit routes.

Output:
- Zod schema for opening validation
- OpeningForm component with spirit selector, metadata fields, and dynamic turns array
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-text-opening-management/05-RESEARCH.md
@convex/schema.ts
@app/components/spirits/turn-accordion.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create opening form schema</name>
  <files>
    app/lib/schemas/opening.ts
  </files>
  <action>
    Create app/lib/schemas/ directory and opening.ts:

    1. Import z from "zod"

    2. Define turn schema:
       ```typescript
       const turnSchema = z.object({
         turn: z.number().min(1),
         title: z.string().optional(),
         instructions: z.string().min(1, "Instructions are required"),
         notes: z.string().optional(),
       });
       ```

    3. Define opening form schema:
       ```typescript
       export const openingFormSchema = z.object({
         spiritId: z.string().min(1, "Spirit is required"),
         name: z.string().min(1, "Name is required").max(100, "Name too long"),
         slug: z.string()
           .min(1, "Slug is required")
           .max(50, "Slug too long")
           .regex(/^[a-z0-9-]+$/, "Slug must be lowercase letters, numbers, and hyphens only"),
         description: z.string().max(500, "Description too long").optional().or(z.literal("")),
         difficulty: z.enum(["Beginner", "Intermediate", "Advanced"]).optional(),
         turns: z.array(turnSchema).min(1, "At least one turn is required"),
         author: z.string().max(100, "Author name too long").optional().or(z.literal("")),
         sourceUrl: z.string().url("Invalid URL").optional().or(z.literal("")),
       });
       ```

    4. Export type:
       ```typescript
       export type OpeningFormData = z.infer<typeof openingFormSchema>;
       ```

    NOTE: Use .optional().or(z.literal("")) for optional text fields to allow empty strings (common form pattern).
  </action>
  <verify>
    Run `pnpm typecheck` - no errors
  </verify>
  <done>
    app/lib/schemas/opening.ts exports openingFormSchema and OpeningFormData type
  </done>
</task>

<task type="auto">
  <name>Task 2: Create OpeningForm component</name>
  <files>
    app/components/admin/opening-form.tsx
  </files>
  <action>
    Create app/components/admin/ directory and opening-form.tsx:

    1. Imports:
       - useForm, useFieldArray from "react-hook-form"
       - zodResolver from "@hookform/resolvers/zod"
       - openingFormSchema, OpeningFormData from "@/lib/schemas/opening"
       - Button from "@/components/ui/button"
       - Plus, Trash2, GripVertical from "lucide-react"

    2. Define props interface:
       ```typescript
       interface Spirit {
         _id: string;
         name: string;
         aspectName?: string;
       }

       interface OpeningFormProps {
         defaultValues?: Partial<OpeningFormData>;
         onSubmit: (data: OpeningFormData) => Promise<void>;
         spirits: Spirit[];
         isSubmitting?: boolean;
       }
       ```

    3. Create OpeningForm component:
       - Initialize useForm with zodResolver(openingFormSchema)
       - Default values: turns: [{ turn: 1, instructions: "", title: "", notes: "" }]
       - Spread any provided defaultValues over defaults
       - Get register, control, handleSubmit, formState: { errors } from useForm
       - Initialize useFieldArray with control and name: "turns"

    4. Form layout (use Tailwind classes matching existing UI):
       a. Spirit selector (select element):
          - Label "Spirit"
          - Options: empty option "Select spirit...", then map spirits
          - Display: name + (aspectName) if aspect
          - Show errors.spiritId?.message

       b. Name and Slug fields (grid grid-cols-2 gap-4):
          - Name: text input with register("name")
          - Slug: text input with register("slug"), placeholder "lowercase-with-hyphens"
          - Show respective error messages

       c. Description field:
          - Textarea with register("description")
          - Placeholder "Brief strategy summary (optional)"

       d. Difficulty selector:
          - Select with options: empty, Beginner, Intermediate, Advanced
          - register("difficulty")

       e. Turns section:
          - Header with "Turns" label and "Add Turn" button
          - Add Turn button: onClick={() => append({ turn: fields.length + 1, instructions: "", title: "", notes: "" })}
          - Map over fields with field.id as key (CRITICAL - never use index as key)
          - Each turn card:
            * Border rounded p-4 with turn number header
            * Remove button (only if fields.length > 1)
            * Hidden input for turn number: register(`turns.${index}.turn`, { valueAsNumber: true })
            * Title input (optional): register(`turns.${index}.title`)
            * Instructions textarea (required): register(`turns.${index}.instructions`)
            * Notes textarea (optional): register(`turns.${index}.notes`)
            * Show errors.turns?.[index]?.instructions?.message

       f. Attribution section (grid grid-cols-2 gap-4):
          - Author: text input, register("author")
          - Source URL: text input type="url", register("sourceUrl")

       g. Submit button:
          - Disabled when isSubmitting
          - Text: isSubmitting ? "Saving..." : "Save Opening"

    5. Style classes to use:
       - Inputs/selects: "w-full border border-border rounded-md p-2 bg-background text-foreground"
       - Labels: "text-sm font-medium text-foreground"
       - Error text: "text-sm text-destructive mt-1"
       - Sections: "space-y-4"

    CRITICAL: Always use field.id as React key in useFieldArray mapping, never array index. This prevents data corruption when removing items.
  </action>
  <verify>
    Run `pnpm typecheck` - no errors
  </verify>
  <done>
    OpeningForm component exists with spirit selector, dynamic turns array using useFieldArray with field.id keys, Zod validation
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. app/lib/schemas/opening.ts exports openingFormSchema
3. app/components/admin/opening-form.tsx exports OpeningForm
4. OpeningForm uses field.id as key in turns mapping (grep for "key={field.id}")
</verification>

<success_criteria>
- Zod schema validates all required fields
- Slug regex enforces lowercase-hyphen pattern
- useFieldArray manages turns with proper field.id keys
- Form handles empty optional fields gracefully
- Error messages display below invalid fields
</success_criteria>

<output>
After completion, create `.planning/phases/05-text-opening-management/05-02-SUMMARY.md`
</output>

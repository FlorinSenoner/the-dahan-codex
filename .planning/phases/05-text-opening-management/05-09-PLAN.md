---
phase: 05-text-opening-management
plan: 09
type: execute
wave: 2
depends_on: ["05-08"]
files_modified:
  - app/components/spirits/opening-section.tsx
  - app/components/admin/editable-opening.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Form changes only saved when user clicks FAB save button"
    - "No auto-save on keystroke"
    - "No infinite loops or flickering when typing"
    - "Form data persists locally until explicit save"
  artifacts:
    - path: "app/components/spirits/opening-section.tsx"
      provides: "Opening section with controlled form state"
    - path: "app/components/admin/editable-opening.tsx"
      provides: "Opening editor with stable onChange callbacks"
  key_links:
    - from: "app/routes/spirits.$slug.tsx"
      to: "app/components/spirits/opening-section.tsx"
      via: "saveHandler callback"
      pattern: "onSaveHandlerReady"
---

<objective>
Fix auto-save flickering by ensuring saves only happen on explicit FAB button click, not on every keystroke. This also enables navigation warnings to work properly.

Purpose: Eliminate infinite loops and UI flickering during fast typing
Output: Stable form editing with explicit save action only
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-text-opening-management/05-VERIFICATION.md

GAP-02 from VERIFICATION.md:
Text inputs trigger saves on every keystroke, causing infinite loops and UI flickering.
Root cause: Form state updates trigger parent callbacks which may cause re-renders.
Save only when user clicks FAB save button, not on every change.

This is CRITICAL - blocking GAP-03, GAP-05, and general usability.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Stabilize EditableOpening callbacks</name>
  <files>app/components/admin/editable-opening.tsx</files>
  <action>
  The issue is that onChange is called on every keystroke, which triggers parent re-renders.

  Concrete changes to make:

  1. Wrap updateField in useCallback with stable dependencies:
     ```tsx
     const updateField = useCallback((field: keyof OpeningFormData, value: string | number) => {
       const newData = { ...formData, [field]: value };
       onChange(newData);
     }, [formData, onChange]);
     ```

  2. Wrap updateTurn in useCallback with stable dependencies:
     ```tsx
     const updateTurn = useCallback((
       turnIndex: number,
       field: keyof TurnData,
       value: string | number
     ) => {
       const newTurns = formData.turns.map((t, i) =>
         i === turnIndex ? { ...t, [field]: value } : t
       );
       onChange({ ...formData, turns: newTurns });
     }, [formData, onChange]);
     ```

  3. Memoize turn handlers with useMemo to prevent child re-renders:
     ```tsx
     const turnHandlers = useMemo(() =>
       formData.turns.map((_, index) => ({
         onUpdateGrowth: (value: number) => updateTurn(index, 'growth', value),
         onUpdateCardPlays: (value: number) => updateTurn(index, 'cardPlays', value),
         onUpdateNotes: (value: string) => updateTurn(index, 'notes', value),
       })),
       [formData.turns.length, updateTurn]
     );
     ```

  4. Remove any useEffect that runs on formData changes (if present)
  </action>
  <verify>
  Run `pnpm typecheck` - compiles
  Manual test: Type rapidly in form fields, no flickering or lag
  </verify>
  <done>Form updates don't cause cascading re-renders</done>
</task>

<task type="auto">
  <name>Task 2: Stabilize parent callbacks in spirits.$slug.tsx</name>
  <files>app/routes/spirits.$slug.tsx, app/components/spirits/opening-section.tsx</files>
  <action>
  The flickering is caused by unstable callback props passed from spirits.$slug.tsx to OpeningSection.

  Concrete changes in app/routes/spirits.$slug.tsx:

  1. Wrap onHasChangesChange in useCallback with empty deps (stable reference):
     ```tsx
     const handleHasChangesChange = useCallback((hasChanges: boolean) => {
       setHasChanges(hasChanges);
     }, []);
     ```
     Then pass handleHasChangesChange instead of inline arrow function.

  2. Wrap onSaveHandlerReady in useCallback with empty deps:
     ```tsx
     const handleSaveHandlerReady = useCallback((handler: (() => Promise<void>) | null) => {
       saveHandlerRef.current = handler;
     }, []);
     ```
     Then pass handleSaveHandlerReady instead of inline arrow function.

  3. Verify NO useEffect in opening-section.tsx auto-triggers saves:
     - Line ~113-115: useEffect notifies parent of hasChanges - OK (keep as-is)
     - Line ~180-182: useEffect exposes save handler - OK (keep as-is)
     - Confirm no other useEffect calls handleSave or similar

  4. Remove any useEffect watching formData that might cause side effects beyond hasChanges notification
  </action>
  <verify>
  Run `pnpm typecheck` - compiles
  Run `pnpm build` - builds successfully
  </verify>
  <done>No auto-save behavior exists, save only on explicit button click</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. `pnpm build` succeeds
3. Manual test: Enter edit mode, type rapidly in any field, no flickering
4. Manual test: Type changes, navigate away without saving - should trigger navigation warning (GAP-05)
</verification>

<success_criteria>
- Fast typing in form fields causes no lag or flicker
- Save button in FAB is the only way to persist changes
- Changes are preserved in form state until explicit save or cancel
</success_criteria>

<output>
After completion, create `.planning/phases/05-text-opening-management/05-09-SUMMARY.md`
</output>

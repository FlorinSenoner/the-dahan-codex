---
phase: 05-text-opening-management
plan: 18
type: execute
wave: 1
depends_on: []
files_modified:
  - app/hooks/use-edit-mode.ts
  - app/contexts/edit-mode-context.tsx
  - app/routes/__root.tsx
  - app/routes/spirits.$slug.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Toggling edit mode does not scroll the page"
    - "Edit mode state persists within session but not in URL"
    - "useEditMode hook interface unchanged (isEditing, toggleEdit, setEditing)"
  artifacts:
    - path: "app/contexts/edit-mode-context.tsx"
      provides: "EditModeContext and EditModeProvider"
      exports: ["EditModeProvider", "useEditModeContext"]
    - path: "app/hooks/use-edit-mode.ts"
      provides: "useEditMode hook using context"
      contains: "useEditModeContext"
    - path: "app/routes/__root.tsx"
      provides: "EditModeProvider wrapper"
      contains: "EditModeProvider"
  key_links:
    - from: "useEditMode"
      to: "EditModeContext"
      via: "useContext"
      pattern: "useEditModeContext"
---

<objective>
Fix scroll jump on edit toggle by converting useEditMode from URL state to React Context.

Purpose: URL navigation causes TanStack Router's scroll restoration to trigger, jumping to top. Using React state avoids navigation entirely.
Output: EditModeContext provider and updated useEditMode hook with same interface.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@app/hooks/use-edit-mode.ts
@app/routes/__root.tsx
@app/routes/spirits.$slug.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EditModeContext</name>
  <files>app/contexts/edit-mode-context.tsx</files>
  <action>
Create new file `app/contexts/edit-mode-context.tsx`:

```typescript
import { createContext, useCallback, useContext, useState } from "react";
import type { ReactNode } from "react";

interface EditModeContextValue {
  isEditMode: boolean;
  setEditMode: (editing: boolean) => void;
}

const EditModeContext = createContext<EditModeContextValue | null>(null);

interface EditModeProviderProps {
  children: ReactNode;
}

export function EditModeProvider({ children }: EditModeProviderProps) {
  const [isEditMode, setIsEditMode] = useState(false);

  const setEditMode = useCallback((editing: boolean) => {
    setIsEditMode(editing);
  }, []);

  return (
    <EditModeContext.Provider value={{ isEditMode, setEditMode }}>
      {children}
    </EditModeContext.Provider>
  );
}

export function useEditModeContext(): EditModeContextValue {
  const context = useContext(EditModeContext);
  if (!context) {
    throw new Error("useEditModeContext must be used within EditModeProvider");
  }
  return context;
}
```
  </action>
  <verify>`pnpm typecheck` passes</verify>
  <done>EditModeContext created with provider and hook</done>
</task>

<task type="auto">
  <name>Task 2: Update useEditMode to use context</name>
  <files>app/hooks/use-edit-mode.ts</files>
  <action>
Replace the entire file content:

```typescript
import { useCallback } from "react";
import { useEditModeContext } from "@/contexts/edit-mode-context";
import { useAdmin } from "./use-admin";

interface EditModeState {
  isEditing: boolean;
  toggleEdit: () => void;
  setEditing: (editing: boolean) => void;
}

export function useEditMode(): EditModeState {
  const { isEditMode, setEditMode } = useEditModeContext();
  const isAdmin = useAdmin();

  // Only activate edit mode if user is admin AND context has edit=true
  const isEditing = isAdmin && isEditMode;

  const setEditing = useCallback(
    (editing: boolean) => {
      setEditMode(editing);
    },
    [setEditMode],
  );

  const toggleEdit = useCallback(() => {
    setEditing(!isEditing);
  }, [isEditing, setEditing]);

  return { isEditing, toggleEdit, setEditing };
}
```

The interface remains identical (isEditing, toggleEdit, setEditing) so no consumer changes needed.
  </action>
  <verify>`pnpm typecheck` passes</verify>
  <done>useEditMode now uses React Context instead of URL state</done>
</task>

<task type="auto">
  <name>Task 3: Add EditModeProvider to root layout</name>
  <files>app/routes/__root.tsx</files>
  <action>
1. Add import at top of file:
```typescript
import { EditModeProvider } from "@/contexts/edit-mode-context";
```

2. Wrap the app content with EditModeProvider. Find the return statement in RootComponent and add EditModeProvider inside the existing providers.

The provider should wrap the content that uses edit mode. Look for where the main app structure is rendered (likely after ClerkProvider/ConvexProviderWithClerk/QueryClientProvider).

Wrap the content inside QueryClientProvider (or the innermost provider before the actual app content):

```typescript
<EditModeProvider>
  {/* existing content like Outlet, PWA components, etc. */}
</EditModeProvider>
```

Note: The exact location depends on the current structure. Place it inside all auth/data providers but wrapping the UI content.
  </action>
  <verify>`pnpm typecheck` passes</verify>
  <done>EditModeProvider added to root layout</done>
</task>

<task type="auto">
  <name>Task 4: Remove edit param from route validation</name>
  <files>app/routes/spirits.$slug.tsx</files>
  <action>
Since edit mode is now managed via React Context (not URL), remove the `edit` param from validateSearch.

Find the validateSearch function (around line 40):
```typescript
export const Route = createFileRoute("/spirits/$slug")({
  validateSearch: (search: Record<string, unknown>) => ({
    edit: search.edit === true || search.edit === "true",
    opening: typeof search.opening === "string" ? search.opening : undefined,
  }),
```

Remove the `edit` line, keeping only `opening`:
```typescript
export const Route = createFileRoute("/spirits/$slug")({
  validateSearch: (search: Record<string, unknown>) => ({
    opening: typeof search.opening === "string" ? search.opening : undefined,
  }),
```

This removes the now-unused URL-based edit state from the route definition.
  </action>
  <verify>
1. `pnpm typecheck` passes
2. `pnpm dev` - test scroll behavior:
   - Navigate to a spirit detail page
   - Scroll down to openings section
   - Click edit FAB to enter edit mode
   - Page should NOT scroll to top
   - Click X to exit edit mode
   - Page should NOT scroll to top
3. Test edit mode still works:
   - Enter edit mode - editing UI appears
   - Exit edit mode - read-only UI appears
   - Admin check still works (non-admins can't enter edit mode)
  </verify>
  <done>Edit param removed from route validation, scroll position preserved on edit toggle</done>
</task>

</tasks>

<verification>
- `pnpm typecheck` passes
- Edit toggle does not cause scroll jump
- Edit mode functions correctly (enter/exit)
- Admin restriction still works
- useEditMode interface unchanged (isEditing, toggleEdit, setEditing)
</verification>

<success_criteria>
- Scroll position preserved when toggling edit mode
- Edit mode UX unchanged (just no scroll jump)
- No breaking changes to existing components using useEditMode
</success_criteria>

<output>
After completion, create `.planning/phases/05-text-opening-management/05-18-SUMMARY.md`
</output>

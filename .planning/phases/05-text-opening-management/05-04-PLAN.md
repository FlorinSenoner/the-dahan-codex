---
phase: 05-text-opening-management
plan: 04
type: execute
wave: 2
depends_on: ["05-01", "05-03"]
files_modified:
  - app/components/admin/editable-text.tsx
  - app/components/admin/editable-opening.tsx
  - app/components/spirits/opening-section.tsx
  - app/components/spirits/turn-accordion.tsx
autonomous: true

must_haves:
  truths:
    - "Text content transforms to textarea/input when in edit mode"
    - "Editable sections show subtle visual indicator in edit mode"
    - "Turn accordion shows editable content when editing"
    - "Difficulty field UI is removed from OpeningSection"
  artifacts:
    - path: "app/components/admin/editable-text.tsx"
      provides: "Reusable editable text component"
      exports: ["EditableText"]
    - path: "app/components/admin/editable-opening.tsx"
      provides: "Full opening editor with turns"
      exports: ["EditableOpening"]
  key_links:
    - from: "app/components/admin/editable-opening.tsx"
      to: "app/components/admin/editable-text.tsx"
      via: "import and use"
      pattern: "EditableText"
    - from: "app/components/spirits/opening-section.tsx"
      to: "app/components/admin/editable-opening.tsx"
      via: "conditional render in edit mode"
      pattern: "isEditing.*EditableOpening"
---

<objective>
Create inline editing components for openings and integrate with existing opening display.

Purpose: Enable admins to edit opening content directly on the spirit detail page without navigating elsewhere.
Output: EditableText, EditableOpening components, updated OpeningSection with edit mode.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-text-opening-management/05-CONTEXT.md
@.planning/phases/05-text-opening-management/05-RESEARCH.md
@app/components/spirits/opening-section.tsx
@app/components/spirits/turn-accordion.tsx
@app/hooks/use-edit-mode.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EditableText component</name>
  <files>app/components/admin/editable-text.tsx</files>
  <action>
Create app/components/admin/editable-text.tsx:

Reusable component that shows text when not editing, input/textarea when editing.

```typescript
import { cn } from '@/lib/utils';

interface EditableTextProps {
  value: string;
  onChange: (value: string) => void;
  isEditing: boolean;
  multiline?: boolean;
  placeholder?: string;
  className?: string;
  displayClassName?: string;
  required?: boolean;
}

export function EditableText({
  value,
  onChange,
  isEditing,
  multiline = false,
  placeholder,
  className,
  displayClassName,
  required = false,
}: EditableTextProps) {
  if (!isEditing) {
    return (
      <span className={cn('text-foreground', displayClassName)}>
        {value || <span className="text-muted-foreground italic">{placeholder || 'Empty'}</span>}
      </span>
    );
  }

  const inputClassName = cn(
    'w-full bg-muted/30 border border-primary/30 rounded px-2 py-1',
    'focus:border-primary focus:ring-1 focus:ring-primary/50 focus:outline-none',
    'text-foreground placeholder:text-muted-foreground',
    className
  );

  if (multiline) {
    return (
      <textarea
        value={value}
        onChange={(e) => onChange(e.target.value)}
        className={cn(inputClassName, 'min-h-[100px] resize-y')}
        placeholder={placeholder}
        required={required}
      />
    );
  }

  return (
    <input
      type="text"
      value={value}
      onChange={(e) => onChange(e.target.value)}
      className={inputClassName}
      placeholder={placeholder}
      required={required}
    />
  );
}
```
  </action>
  <verify>pnpm typecheck passes</verify>
  <done>EditableText component created with input/textarea modes</done>
</task>

<task type="auto">
  <name>Task 2: Create EditableOpening component</name>
  <files>app/components/admin/editable-opening.tsx</files>
  <action>
Create app/components/admin/editable-opening.tsx:

Full opening editor with:
- Opening name (required)
- Description (optional)
- List of turns with add/delete
- Author and source URL fields
- Delete opening button
- NO difficulty field (removed from schema in 05-01)

```typescript
import type { Doc, Id } from 'convex/_generated/dataModel';
import { Plus, Trash2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Heading, Text } from '@/components/ui/typography';
import { EditableText } from './editable-text';

interface Turn {
  turn: number;
  title?: string;
  instructions: string;
  notes?: string;
}

interface OpeningFormData {
  name: string;
  description: string;
  turns: Turn[];
  author: string;
  sourceUrl: string;
}

interface EditableOpeningProps {
  opening: Doc<'openings'> | null;
  formData: OpeningFormData;
  onChange: (data: OpeningFormData) => void;
  onDelete?: () => void;
  isNew?: boolean;
}

export function EditableOpening({
  opening,
  formData,
  onChange,
  onDelete,
  isNew = false,
}: EditableOpeningProps) {
  const updateField = <K extends keyof OpeningFormData>(
    field: K,
    value: OpeningFormData[K]
  ) => {
    onChange({ ...formData, [field]: value });
  };

  const updateTurn = (index: number, updates: Partial<Turn>) => {
    const newTurns = [...formData.turns];
    newTurns[index] = { ...newTurns[index], ...updates };
    updateField('turns', newTurns);
  };

  const addTurn = () => {
    const nextTurn = formData.turns.length + 1;
    updateField('turns', [
      ...formData.turns,
      { turn: nextTurn, title: '', instructions: '', notes: '' },
    ]);
  };

  const deleteTurn = (index: number) => {
    if (!confirm('Delete this turn?')) return;
    const newTurns = formData.turns
      .filter((_, i) => i !== index)
      .map((t, i) => ({ ...t, turn: i + 1 })); // Renumber turns
    updateField('turns', newTurns);
  };

  return (
    <div className="bg-card border border-primary/30 rounded-lg p-4 space-y-4 ring-1 ring-primary/20">
      {/* Opening Name */}
      <div>
        <Text variant="small" className="text-muted-foreground mb-1">
          Opening Name *
        </Text>
        <EditableText
          value={formData.name}
          onChange={(v) => updateField('name', v)}
          isEditing={true}
          placeholder="e.g., Standard Opening"
          required
          className="font-semibold text-lg"
        />
      </div>

      {/* Description */}
      <div>
        <Text variant="small" className="text-muted-foreground mb-1">
          Description
        </Text>
        <EditableText
          value={formData.description}
          onChange={(v) => updateField('description', v)}
          isEditing={true}
          multiline
          placeholder="Brief strategy overview..."
        />
      </div>

      {/* Turns */}
      <div className="space-y-3">
        <Text variant="small" className="text-muted-foreground">
          Turns
        </Text>
        {formData.turns.map((turn, index) => (
          <div
            key={turn.turn}
            className="border border-border rounded-lg p-3 space-y-2 bg-muted/10"
          >
            <div className="flex items-center justify-between">
              <Text variant="small" className="font-medium">
                Turn {turn.turn}
              </Text>
              <Button
                variant="ghost"
                size="icon"
                className="h-8 w-8 text-destructive hover:text-destructive"
                onClick={() => deleteTurn(index)}
                aria-label={`Delete turn ${turn.turn}`}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </div>
            <EditableText
              value={turn.title || ''}
              onChange={(v) => updateTurn(index, { title: v })}
              isEditing={true}
              placeholder="Turn title (optional)"
              className="text-sm"
            />
            <EditableText
              value={turn.instructions}
              onChange={(v) => updateTurn(index, { instructions: v })}
              isEditing={true}
              multiline
              placeholder="Instructions for this turn..."
              required
            />
            <EditableText
              value={turn.notes || ''}
              onChange={(v) => updateTurn(index, { notes: v })}
              isEditing={true}
              multiline
              placeholder="Additional notes (optional)"
              className="text-sm"
            />
          </div>
        ))}
        <Button
          variant="outline"
          size="sm"
          onClick={addTurn}
          className="w-full"
        >
          <Plus className="h-4 w-4 mr-2" />
          Add Turn
        </Button>
      </div>

      {/* Attribution */}
      <div className="grid grid-cols-2 gap-4">
        <div>
          <Text variant="small" className="text-muted-foreground mb-1">
            Author
          </Text>
          <EditableText
            value={formData.author}
            onChange={(v) => updateField('author', v)}
            isEditing={true}
            placeholder="Author name"
          />
        </div>
        <div>
          <Text variant="small" className="text-muted-foreground mb-1">
            Source URL
          </Text>
          <EditableText
            value={formData.sourceUrl}
            onChange={(v) => updateField('sourceUrl', v)}
            isEditing={true}
            placeholder="https://..."
          />
        </div>
      </div>

      {/* Delete Opening */}
      {!isNew && onDelete && (
        <div className="pt-4 border-t border-border">
          <Button
            variant="destructive"
            size="sm"
            onClick={() => {
              if (confirm('Delete this opening? This cannot be undone.')) {
                onDelete();
              }
            }}
          >
            <Trash2 className="h-4 w-4 mr-2" />
            Delete Opening
          </Button>
        </div>
      )}
    </div>
  );
}
```
  </action>
  <verify>pnpm typecheck passes</verify>
  <done>EditableOpening component created with turn management, no difficulty field</done>
</task>

<task type="auto">
  <name>Task 3: Update OpeningSection for edit mode and remove difficulty UI</name>
  <files>app/components/spirits/opening-section.tsx</files>
  <action>
Update app/components/spirits/opening-section.tsx:

**IMPORTANT: Remove difficulty field UI** - The schema is removing difficulty in 05-01, so the UI must also stop displaying it. Remove the Badge showing `opening.difficulty` (lines 55-59 in current file).

1. Import useEditMode hook
2. Import EditableOpening component
3. Add local state for form data (track changes)
4. Show EditableOpening when editing, TurnAccordion when not
5. Add "Add Opening" button for admin when no openings exist
6. Track hasChanges for the parent to use with EditFab
7. **REMOVE the difficulty Badge** - delete the conditional rendering of difficulty

Key changes:
- Add props: onOpeningChange, onHasChangesChange callbacks
- When entering edit mode, initialize form data from opening
- When form changes, call onOpeningChange with new data
- Calculate hasChanges by comparing form data to original
- Show editable UI only when isEditing is true
- Remove difficulty display from read-only view

```typescript
// Add to imports
import { useState, useEffect, useCallback } from 'react';
import { Plus } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { useEditMode } from '@/hooks/use-edit-mode';
import { EditableOpening } from '@/components/admin/editable-opening';

// Add new props interface
interface OpeningSectionProps {
  spiritId: Id<'spirits'>;
  onFormDataChange?: (data: OpeningFormData | null, openingId: Id<'openings'> | null) => void;
  onHasChangesChange?: (hasChanges: boolean) => void;
}

// Inside component, add edit mode handling
const { isEditing } = useEditMode();

// Initialize form data when entering edit mode or opening changes
// ... (implementation details)

// In the read-only display section:
// REMOVE the difficulty Badge:
// DELETE this block:
//   {opening.difficulty && (
//     <Badge variant="outline" className="text-xs">
//       {opening.difficulty}
//     </Badge>
//   )}

// Render logic:
// If editing && has opening: show EditableOpening
// If editing && no opening: show "Add Opening" button + maybe empty EditableOpening
// If not editing: show existing display (TurnAccordion) WITHOUT difficulty Badge
```

Note: Keep the existing display logic for non-edit mode. The edit UI should layer on top.
  </action>
  <verify>
1. pnpm typecheck passes
2. pnpm dev shows edit mode toggle working
3. No difficulty badge visible in read-only view
4. Grep for "difficulty" in opening-section.tsx returns no matches (or only in comments)
  </verify>
  <done>OpeningSection shows editable UI for admins in edit mode, difficulty UI completely removed from read-only view</done>
</task>

</tasks>

<verification>
1. pnpm typecheck passes
2. EditableText switches between display and input modes
3. EditableOpening renders with all fields editable (no difficulty field)
4. Turn add/delete works with proper renumbering
5. OpeningSection shows edit UI when isEditing is true
6. Difficulty badge is NOT displayed in read-only view
</verification>

<success_criteria>
- Text transforms to editable inputs in edit mode
- Turns can be added and deleted
- Editable sections have subtle border/highlight (ring-1 ring-primary/20)
- Form data changes are tracked for hasChanges state
- Difficulty field UI is completely removed from OpeningSection
</success_criteria>

<output>
After completion, create `.planning/phases/05-text-opening-management/05-04-SUMMARY.md`
</output>
